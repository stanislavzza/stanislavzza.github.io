<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="David Eubanks">

<title>Chapter 5: Hierarchical Models – The Kappa Zoo</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-fcd204c8655bd031ced4918abb783b1b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-XP6WMESY52"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-XP6WMESY52', { 'anonymize_ip': true});
</script>
<script src="site_libs/kePrint-0.0.1/kePrint.js"></script>

<link href="site_libs/lightable-0.0.1/lightable.css" rel="stylesheet">


  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">
      The Kappa Zoo
      </li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">The Kappa Zoo</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sec-intro" id="toc-sec-intro" class="nav-link active" data-scroll-target="#sec-intro"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#sec-likelihood" id="toc-sec-likelihood" class="nav-link" data-scroll-target="#sec-likelihood"><span class="header-section-number">2</span> Hierarchical Likelihood</a></li>
  <li><a href="#sec-em" id="toc-sec-em" class="nav-link" data-scroll-target="#sec-em"><span class="header-section-number">3</span> Direct E-M Estimation</a></li>
  <li><a href="#mcmc-estimation" id="toc-mcmc-estimation" class="nav-link" data-scroll-target="#mcmc-estimation"><span class="header-section-number">4</span> MCMC Estimation</a></li>
  <li><a href="#machine-learning-models" id="toc-machine-learning-models" class="nav-link" data-scroll-target="#machine-learning-models"><span class="header-section-number">5</span> Machine Learning Models</a>
  <ul class="collapse">
  <li><a href="#sec-dawid-skene" id="toc-sec-dawid-skene" class="nav-link" data-scroll-target="#sec-dawid-skene"><span class="header-section-number">5.1</span> Dawid &amp; Skene</a></li>
  <li><a href="#sec-mace" id="toc-sec-mace" class="nav-link" data-scroll-target="#sec-mace"><span class="header-section-number">5.2</span> MACE</a></li>
  </ul></li>
  <li><a href="#groupthink" id="toc-groupthink" class="nav-link" data-scroll-target="#groupthink"><span class="header-section-number">6</span> Groupthink</a></li>
  <li><a href="#invariant-scales" id="toc-invariant-scales" class="nav-link" data-scroll-target="#invariant-scales"><span class="header-section-number">7</span> Invariant Scales</a></li>
  <li><a href="#partial-pooling" id="toc-partial-pooling" class="nav-link" data-scroll-target="#partial-pooling"><span class="header-section-number">8</span> Partial Pooling</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Chapter 5: Hierarchical Models</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>David Eubanks </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="sec-intro" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>In <a href="./paradox.html">Chapter 4: The Kappa Paradox</a> we saw how adding parameters can increase the explanatory power of t-a-p models. This is an old idea. The Cohen kappa <span class="citation" data-cites="cohen1960coefficient">(<a href="#ref-cohen1960coefficient" role="doc-biblioref">Cohen, 1960</a>)</span> dates from the 1960s, and for large data sets can be seen as a variation of the Fleiss kappa, but where each rater has a parameter for random assigments. In the original paper, the formula is derived for two rates, but it can be expanded to any number of them. <span class="citation" data-cites="dawid1979maximum">Dawid &amp; Skene (<a href="#ref-dawid1979maximum" role="doc-biblioref">1979</a>)</span> proposed a more ambitious rater model that entailed multiple coefficients per rater and a truth parameter for each subject.</p>
<p>A natural expansion of the t-a-p model assigns coefficients for each rater and subject. For example, we could assign a truth parameter <span class="math inline">\(t_i\)</span> to each subject <span class="math inline">\(i\)</span>, and accuracy and random assignment parameters <span class="math inline">\(a_j\)</span> and <span class="math inline">\(p_j\)</span>, respectively, to each rater <span class="math inline">\(j\)</span>. The latter requires that we have IDs for the raters. Generally, regression models like this are called hierarchical models or random effects models or fixed effects models, depending on the research tradition (As noted in <span class="citation" data-cites="agresti2003categorical">Agresti (<a href="#ref-agresti2003categorical" role="doc-biblioref">2003</a>)</span>, p.&nbsp;523 and <span class="citation" data-cites="gelman2006data">Gelman &amp; Hill (<a href="#ref-gelman2006data" role="doc-biblioref">2006</a>)</span>, p.&nbsp;245, fixed versus random effects are not good descriptions for Bayesian models).</p>
<p>The three parameter t-a-p model is <em>already</em> hierarchical in the sense that the ratings for each subject are clustered for analysis. That’s how we create a distribution of agreement to compare with a binomial mixture. The hierarchical model we’re discussing in this chapter is a further extension of that idea, where we add parameters to the model, generally for one of two reasons. One reason is to increase model fit by accounting for variation in the data that is not explained by the three average parameters. The other reason is to obtain estimates for individual subjects or raters.</p>
<p>Individual rater parameters and subject truth values are of interest in many contexts. In educational psychology, we might want to know how well a teacher is able to assess student learning, and how well the students demonstrate knowledge or skill. In medical research, we might want to know how well a doctor is able to diagnose a disease, and how well the patients are responding to treatment. In machine learning, we may be concerned with the quality of training data drawn from human classifications. The ratings of consumer products on sites like Amazon or Yelp can be polluted with unfaithful reviews, so some means of detection is valuable. Likewise, individual subject truth parameters are valuable if we want to make decisions with the rating data, for example in a medical diagnosis, a pass/fail assessment of student learning, or using product ratings to make a selection.</p>
</section>
<section id="sec-likelihood" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Hierarchical Likelihood</h1>
<p>A general characteristic of hierarchical models is that the probability of an individual rating being Class 1 can depend on the particular rater, subject, and possibly other factors. It will be useful to describe the likelihood of the ratings data in general. This can then be customized to t-a-p models and others we’ll encounter. Following <span class="citation" data-cites="dawid1979maximum">Dawid &amp; Skene (<a href="#ref-dawid1979maximum" role="doc-biblioref">1979</a>)</span>, I’ll use the notation</p>
<p><span class="math display">\[
Pr(\text{Rating is Class n | True class is m}) = \pi_{mn}
\]</span> It may help to think of the <span class="math inline">\(\pi\)</span>s as elements from a square matrix of size <span class="math inline">\(k\)</span>, the number of rating categories, where each row corresponds to a true class, and the elements in that row (the columns) describe a distribution of ratings for that class. A perfectly accurate set of ratings would be represented by the identity matrix. Because we want to individualize these probabilities to raters, we need to index them accordingly, and following Dawid &amp; Skene again, I’ll use a superscript in parentheses, so that <span class="math inline">\(\pi_{01}^{(j)}\)</span> is the probability that the <span class="math inline">\(j\)</span>th rater assigns Class 1 when the true class is 0, and so on.</p>
<p>The JTB truth model is still assumed, so that each subject <span class="math inline">\(i\)</span> has a latent true class <span class="math inline">\(T_i\)</span>. To develop the form of the likelihood equation, take a small example with a subject that receives two ratings of Class 1 and one rating of Class 0. The joint probability (likelihood) of the three ratings is the product of their individual probabilites due to the independence assumption. In practice, we don’t know the value of <span class="math inline">\(T_1\)</span>, so we write</p>
<p><span class="math display">\[
\begin{aligned}
Pr(\text{ratings}) &amp;= \left( \pi_{11}^{(1)} T_1+  \pi_{01}^{(1)} \overline{T}_1  \right)\left( \pi_{11}^{(2)} T_1+  \pi_{01}^{(2)} \overline{T}_1  \right) \left( \pi_{10}^{(3)} T_1+  \pi_{00}^{(3)} \overline{T}_1  \right) \\
                   &amp;= T_1\pi_{11}^{(1)} \pi_{11}^{(2)} \pi_{10}^{(3)} + \overline{T}_1 \pi_{01}^{(1)} \pi_{01}^{(2)}\pi_{10}^{(3)} \,\text{ since } T_1\overline{T}_1 = 0\\
&amp; \approx t_1\pi_{11}^{(1)} \pi_{11}^{(2)} \pi_{10}^{(3)} + \bar{t}_1 \pi_{01}^{(1)} \pi_{01}^{(2)}\pi_{00}^{(3)}                 .
\end{aligned}
\]</span> Recall that superscripts <span class="math inline">\((1), (2), \dots\)</span> identify unique raters. The first subscript in <span class="math inline">\(\pi_{ij}\)</span> is the subject’s true class, and the second is the rating assigned. Since there’s a common true class <span class="math inline">\(T_1\)</span> for all the ratings (binary 0 or 1), the algebraic expansion of the first line simplifies to one of the two possibilities in the second line. We have a choice here, to either guess the values of the binary truth values <span class="math inline">\(T_i\)</span> or downgrade to a probability <span class="math inline">\(t_i\)</span> of subject <span class="math inline">\(i\)</span> being Class 1, in which case we get the last line.</p>
<p>A general likelihood formula for probabilistic <span class="math inline">\(t_i\)</span> is</p>
<p><span id="eq-likelihood1"><span class="math display">\[
Pr(\text{ratings ; parameters}) = \prod_{i}\left( t_i \prod_{j,k_j} \pi_{1k_j}^{(j)} + \bar{t}_i \prod_{j,k_j} \pi_{0k_j}^{(j)} \right),
\tag{1}\]</span></span></p>
<p>which can be understood as multiplying together a likelihood factor for each subject <span class="math inline">\(i\)</span>. These factors are of the form illustrated above in the simple example. Each subject-specific factor is a sum of two products; one for the possibility that the subject might be Class 1 and one for Class 0. These term-products over <span class="math inline">\(j,k_j\)</span> multiply <span class="math inline">\(\pi\)</span> coefficients for each rater <span class="math inline">\(j\)</span> on subject <span class="math inline">\(i\)</span>, with the coefficient chosen for the class <span class="math inline">\(k_j\)</span> assigned by the rater to that subject. This idea can be extended beyond binary classifications, as in <span class="citation" data-cites="dawid1979maximum">Dawid &amp; Skene (<a href="#ref-dawid1979maximum" role="doc-biblioref">1979</a>)</span>, which is described in more detail in <a href="#sec-dawid-skene" class="quarto-xref">Section&nbsp;5.1</a>.</p>
<p>When applied to the t-a-p model, the generic <span class="math inline">\(\pi\)</span> parameters become</p>
<p><span id="eq-tap-pi"><span class="math display">\[
\begin{aligned}
\pi_{00} &amp;= Pr(\text{assigned Class }0|\text{true class }0) = a + \bar{a}\bar{p}  \\
\pi_{01} &amp;= Pr(\text{assigned Class }1|\text{true class }0) = \bar{a}p\\
\pi_{10} &amp;= Pr(\text{assigned Class }0|\text{true class }1) = \bar{a} \bar{p} \\
\pi_{11} &amp;= Pr(\text{assigned Class }1|\text{true class }1) = a + \bar{a}p.\\
\end{aligned}
\tag{2}\]</span></span></p>
<p>The <span class="math inline">\(j\)</span> indicies are suppressed here for clarity, but in the hierarchical model, each rater has a set of these <span class="math inline">\(\pi\)</span> coefficients. Applying these t-a-p model assumptions to the likelihood model <a href="#eq-likelihood1" class="quarto-xref">Equation&nbsp;1</a> gives us a computable formula. We can estimate parameters using an EM-type approach, by extending the method describe in <a href="./tapmodel.html">Chapter 2</a> to individual rater parameters.</p>
<p>For a discussion on the usefulness of log likelihood as a measure of model fit, see <a href="./fit.html">Chapter 6</a>. There we see it’s useful to normalize likelihood as entropy, measured in bits per rating. Maximizing likelihood is the same as minimizing model entropy. To compute the log likelihood as a comparable entropy in bits per rating with the <code>tapModel</code> package, use <code>bits_per_rating(rating_params)</code>. Also see the examples for use cases.</p>
</section>
<section id="sec-em" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Direct E-M Estimation</h1>
<p>In the hierarchical case, the E-step, which is to estimate <span class="math inline">\(t_i\)</span> for each subject, is the same as it is for the three-parameter model, except that we’ll use estimates for individual rater parameters <span class="math inline">\(a_j\)</span> and <span class="math inline">\(p_j\)</span>, instead of the average <span class="math inline">\(a\)</span> and <span class="math inline">\(p\)</span>, as well as some initial estimate for <span class="math inline">\(t_i\)</span>. We’ll take our cue from <a href="#eq-likelihood1" class="quarto-xref">Equation&nbsp;1</a>, and use Bayes’ Rule to write</p>
<p><span class="math display">\[
\begin{aligned}
t_i^* &amp;\approx  Pr(T_i = 1  |\text{ ratings)} \\
&amp;= \frac{Pr(\text{ratings}|T_i = 1)Pr(T_i = 1)}{Pr(\text{ratings})} \\
&amp;=  \frac{t_{avg}Pr(\text{ratings}|T_i = 1)}{t_{avg}Pr(\text{ratings}|T_i = 1) + \bar{t}_{avg}Pr(\text{ratings}|T_i = 0)} \\
&amp;=\frac{t_{avg}\prod_{j,k_j} \pi_{1k_j}^{(j)}}{t_{avg}\prod_{j,k_j} \pi_{1k_j}^{(j)} + \bar{t}_{avg}\prod_{j,k_j} \pi_{0k_j}^{(j)}} ,
\end{aligned}
\]</span></p>
<p>where the asterisk denotes the updated parameter. The denominator is the additive mixture of the likelihoods of seeing the evidence given that the true class is 1 or 0, as denoted in the first subscript. This step can be accomplished with <code>tapModel::estimate_ti()</code>.</p>
<p>In the usual Bayesian terminology, <span class="math inline">\(Pr(T_i = 1)\)</span> is the “prior distribution” of the probability that subject <span class="math inline">\(i\)</span> is true. We have choices for that distribution. We could dodge the question by just setting that factor to 1 as an improper distrbution. Or we could use the uniform (uninformative) distribution <span class="math inline">\(t = .5\)</span> for all subjects. The most informative prior is to use the previous estimate for <span class="math inline">\(t_i\)</span>, but this can be counter-productive if we get off to a bad start, because the prior will keep pulling the estimate back to the lousy first guess. Informally, I’ve found that a good compromise is to use the average <span class="math inline">\(t\)</span> over all subjects from the current estimation as a good prior. That’s the way the formula is written with <span class="math inline">\(Pr(T_i = 1) = t_{avg}\)</span>.</p>
<p>It’s important to note that we’re not maximizing likelihood at this step. If we were, a glance at <a href="#eq-likelihood1" class="quarto-xref">Equation&nbsp;1</a> shows that for each subject, one of the two terms is likely to be larger than the other, in which case we could maximize likelihood by rounding <span class="math inline">\(t_i\)</span> to one or zero.</p>
<p>The maximization step of the E-M loop is similar to the average parameter case described in Chapter 2. Suppose that we estimate the <span class="math inline">\(t_i\)</span> parameters as just described, and that we have rater IDs in the data set. Then for each rater we can create a confusion matrix of the ratings they assigned versus the estimated true class probabilities. From <a href="./introduction.html">Chapter 1</a> we have the following average rates in the table, where the average true Class 1 rate <span class="math inline">\(t\)</span> is taken over a particular rater <span class="math inline">\(i\)</span>, who has parameters <span class="math inline">\(a_j\)</span> and <span class="math inline">\(p_j\)</span> are now specific to rater <span class="math inline">\(j\)</span>.</p>
<div id="tbl-tap-confusion" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-tap-confusion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: The confusion matrix for a combination of raters <span class="math inline">\(R\)</span> and Class 1 ratings <span class="math inline">\(k\)</span> applied rater <span class="math inline">\(j\)</span>. Terms in parentheses are inaccurate ratings. TPP = true positive proportion, etc.
</figcaption>
<div aria-describedby="tbl-tap-confusion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 27%">
<col style="width: 47%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>True C1</th>
<th>True C0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Classified C1</td>
<td>TPP <span class="math inline">\(= ta_j + (t\bar{a}_jp_j)\)</span></td>
<td>FPP <span class="math inline">\(=(\bar{t}\bar{a}_jp_j)\)</span></td>
</tr>
<tr class="even">
<td>Classified C0</td>
<td>FNP <span class="math inline">\(=(t\bar{a}_j\bar{p}_j)\)</span></td>
<td>TNP <span class="math inline">\(=\bar{t}a_j + (\bar{t}\bar{a}_j\bar{p}_j)\)</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>We can populate the estimated probabilities in the confusion matrix in <a href="#tbl-tap-confusion" class="quarto-xref">Table&nbsp;1</a>, from empirical values, such as $ TPP t_iC_{ij}/N$, which is the average match between the true class and the rating. The other three entries can be obtained similarly.</p>
<p>We can then use algebra to solve for estimates of <span class="math inline">\(a_j\)</span> and <span class="math inline">\(p_j\)</span> parameters, with</p>
<p><span class="math display">\[
\begin{aligned}
a_j &amp; \approx \text{TPR}/t - \text{FPR}/\bar{t} \\
p_j &amp; \approx \frac{\text{FPR}}{\bar{a}_j\bar{t}} \, ,
\end{aligned}
\]</span> where <span class="math inline">\(t\)</span> is averaged over the subjects being rated by rater <span class="math inline">\(j\)</span>.</p>
<p>To illustrate, we’ll generate some ratings with known parameters.</p>
<div class="cell">
<details class="code-fold">
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>ratings <span class="ot">&lt;-</span> <span class="fu">generate_ti_aj_pj_ratings</span>(<span class="at">param_list =</span> <span class="fu">list</span>(</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>                                        <span class="at">t =</span> <span class="fu">sample</span>(<span class="dv">0</span><span class="sc">:</span><span class="dv">1</span>, <span class="dv">50</span>, <span class="at">replace =</span> <span class="cn">TRUE</span>),</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>                                        <span class="at">a =</span> <span class="fu">seq</span>(.<span class="dv">1</span>, .<span class="dv">9</span>, .<span class="dv">1</span>),</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                                        <span class="at">p =</span> <span class="fu">rep</span>(.<span class="dv">5</span>, <span class="dv">9</span>)))</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># compute the rating parameters, t_i, a_j, p_j</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>rating_params <span class="ot">&lt;-</span> tapModel<span class="sc">::</span><span class="fu">fit_ratings</span>(ratings)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># extract the rater parameters</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>rating_params <span class="sc">|&gt;</span> </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(rater_id) <span class="sc">|&gt;</span> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">c_j =</span> <span class="fu">mean</span>(rating),</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            <span class="at">a_j =</span> <span class="fu">first</span>(a),</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            <span class="at">p_j =</span> <span class="fu">first</span>(p),</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>            <span class="at">bias =</span> <span class="fu">mean</span>(p <span class="sc">-</span> t)) <span class="sc">|&gt;</span> </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(a_j) <span class="sc">|&gt;</span> </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="at">digits =</span> <span class="dv">2</span>) <span class="sc">|&gt;</span> </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable_styling</span>(</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="at">full_width =</span> <span class="cn">FALSE</span>,           <span class="co"># &lt;- stops spanning the full page</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="at">position   =</span> <span class="st">"center"</span>,</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="at">bootstrap_options =</span> <span class="fu">c</span>(<span class="st">"striped"</span>,<span class="st">"hover"</span>,<span class="st">"condensed"</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="tbl-rater-params" class="cell quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-rater-params-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2: Randomly generated ratings with nine raters having accuracy .1 through .9, using the E-M algorithm to reconstruct the parameters.
</figcaption>
<div aria-describedby="tbl-rater-params-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="table table-striped table-hover table-condensed do-not-create-environment cell caption-top table-sm small" data-quarto-postprocess="true">
<thead>
<tr class="header">
<th style="text-align: right;" data-quarto-table-cell-role="th">rater_id</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">c_j</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">a_j</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">p_j</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">bias</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">0.44</td>
<td style="text-align: right;">0.15</td>
<td style="text-align: right;">0.44</td>
<td style="text-align: right;">0.02</td>
</tr>
<tr class="even">
<td style="text-align: right;">3</td>
<td style="text-align: right;">0.52</td>
<td style="text-align: right;">0.26</td>
<td style="text-align: right;">0.55</td>
<td style="text-align: right;">0.13</td>
</tr>
<tr class="odd">
<td style="text-align: right;">2</td>
<td style="text-align: right;">0.44</td>
<td style="text-align: right;">0.39</td>
<td style="text-align: right;">0.45</td>
<td style="text-align: right;">0.03</td>
</tr>
<tr class="even">
<td style="text-align: right;">4</td>
<td style="text-align: right;">0.48</td>
<td style="text-align: right;">0.39</td>
<td style="text-align: right;">0.52</td>
<td style="text-align: right;">0.10</td>
</tr>
<tr class="odd">
<td style="text-align: right;">6</td>
<td style="text-align: right;">0.40</td>
<td style="text-align: right;">0.45</td>
<td style="text-align: right;">0.38</td>
<td style="text-align: right;">-0.04</td>
</tr>
<tr class="even">
<td style="text-align: right;">5</td>
<td style="text-align: right;">0.42</td>
<td style="text-align: right;">0.50</td>
<td style="text-align: right;">0.42</td>
<td style="text-align: right;">0.00</td>
</tr>
<tr class="odd">
<td style="text-align: right;">7</td>
<td style="text-align: right;">0.44</td>
<td style="text-align: right;">0.65</td>
<td style="text-align: right;">0.48</td>
<td style="text-align: right;">0.05</td>
</tr>
<tr class="even">
<td style="text-align: right;">8</td>
<td style="text-align: right;">0.36</td>
<td style="text-align: right;">0.84</td>
<td style="text-align: right;">0.04</td>
<td style="text-align: right;">-0.38</td>
</tr>
<tr class="odd">
<td style="text-align: right;">9</td>
<td style="text-align: right;">0.46</td>
<td style="text-align: right;">0.93</td>
<td style="text-align: right;">0.99</td>
<td style="text-align: right;">0.57</td>
</tr>
</tbody>
</table>
</div>
</div>
</figure>
</div>
</div>
<p>There is a lot of detailed information in <a href="#tbl-rater-params" class="quarto-xref">Table&nbsp;2</a> that we seem to get for almost free. We’ll continue this discussion in <a href="./fit.html">Chapter 6: Assessing Model Fit</a>.</p>
</section>
<section id="mcmc-estimation" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> MCMC Estimation</h1>
<p>We can use Bayesian models using Markov Chain Monte Carlo (MCMC) algorithms to estimate parameters, as we did in Chapter 4, but this time for the whole parameter set that includes individual raters and subjects. The provided functions end with <code>_mcmc</code> to differentiate them from the non-Bayesian version. The specifications are written in Stan code, which requires installation of <code>library(cmdstanr)</code>. In addition to richer output in the form of parameter draws, MCMC methods can easily be extended, for example to use partial pooling (see the section below on that topic).</p>
<p>An example using <code>fit_ratings_mcmc()</code> is given in the next section. By default, this function first runs the EM algorithm described in the previous section to provide starting estimates for the MCMC algorithm, which speeds it up considerably.</p>
<p>The Stan script substitutes <a href="#eq-tap-pi" class="quarto-xref">Equation&nbsp;2</a> computations into <a href="#eq-likelihood1" class="quarto-xref">Equation&nbsp;1</a>. Stan works with log likelihood, so the products become sums.</p>
<details>
<summary>
View Stan code
</summary>
<div class="sourceCode" id="cb2"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">//   A t_i-a_j-p_j model</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">//   The development is described in the hierarchical chapter. It collapses</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">//   T_i (binary) into t_i (probability) at the subject level. Compare this to</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">//   the model (t_i)-a_j-p_j.stan, which collapses right away, so that each</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">//   rater applies the probability independently instead of at the subject level.</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Learn more about model development with Stan at:</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">//    http://mc-stan.org/users/interfaces/rstan.html</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">//    https://github.com/stan-dev/rstan/wiki/RStan-Getting-Started</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">// The ratings summary (number of 1-ratings per case) and descriptives</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> {</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; N;   <span class="co">// number of ratings</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; S;   <span class="co">// number of subjects being rated</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; R;   <span class="co">// number of unique raters</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[N] <span class="dt">int</span> rating;        <span class="co">// array of binary ratings</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[N] <span class="dt">int</span> subject_index; <span class="co">// the ID of the subject for the ith rating. Should be in 1:S</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[N] <span class="dt">int</span> rater_index; <span class="co">// the ID of the rater for the ith rating. Should be in 1:R</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[R] <span class="dt">real</span>&lt;<span class="kw">lower</span> = <span class="dv">0</span>, <span class="kw">upper</span> = <span class="dv">1</span>&gt; p_est;</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[R] <span class="dt">real</span>&lt;<span class="kw">lower</span> = <span class="dv">0</span>, <span class="kw">upper</span> = <span class="dv">1</span>&gt; a_est;  <span class="co">// rater random parameter</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[S] <span class="dt">real</span>&lt;<span class="kw">lower</span> = <span class="dv">0</span>, <span class="kw">upper</span> = <span class="dv">1</span>&gt; t_est;  <span class="co">// rater random parameter</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> t_prior_sd;</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> a_prior_sd;</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> p_prior_sd;</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; use_uniform_t; <span class="co">// 1 if uniform(0, 1) is used for t, 0 otherwise</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; use_uniform_a; <span class="co">// 1 if uniform(0, 1) is used for a, 0 otherwise</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; use_uniform_p; <span class="co">// 1 if uniform(0, 1) is used for p</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a><span class="co">// The parameters to estimate</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a><span class="kw">parameters</span> {</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>  <span class="co">// random effects</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[R] <span class="dt">real</span>&lt;<span class="kw">lower</span> = <span class="dv">0</span>, <span class="kw">upper</span> = <span class="dv">1</span>&gt; p;</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[R] <span class="dt">real</span>&lt;<span class="kw">lower</span> = <span class="dv">0</span>, <span class="kw">upper</span> = <span class="dv">1</span>&gt; a;  <span class="co">// rater random parameter</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[S] <span class="dt">real</span>&lt;<span class="kw">lower</span> = <span class="dv">0</span>, <span class="kw">upper</span> = <span class="dv">1</span>&gt; t; <span class="co">// the estimated true class probability for subjects</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a><span class="co">// compute the log pis for each rater</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a><span class="kw">transformed parameters</span> {</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[R] <span class="dt">real</span> lpi_00; <span class="co">// Pr(Assigned class = 0 | True class = 0)</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[R] <span class="dt">real</span> lpi_01;</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[R] <span class="dt">real</span> lpi_10;</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[R] <span class="dt">real</span> lpi_11;</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>  <span class="co">// for efficiency precompute the logs</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span>:R){</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>      lpi_00[i] = log(<span class="dv">1</span>-(<span class="dv">1</span>-a[i])*p[i]);</span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>      lpi_10[i] = log((<span class="dv">1</span>-a[i])*(<span class="dv">1</span>-p[i]));</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>      lpi_01[i] = log((<span class="dv">1</span>-a[i])*p[i]);</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>      lpi_11[i] = log(a[i] + (<span class="dv">1</span>-a[i])*p[i] );</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a><span class="co">// The model to be estimated.</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a><span class="kw">model</span> {</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>  <span class="co">// accumulation of log likelihood by subject</span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[S] <span class="dt">real</span> sub_00 = rep_array(<span class="fl">0.0</span>, S);</span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[S] <span class="dt">real</span> sub_01 = rep_array(<span class="fl">0.0</span>, S);</span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[S] <span class="dt">real</span> sub_10 = rep_array(<span class="fl">0.0</span>, S);</span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[S] <span class="dt">real</span> sub_11 = rep_array(<span class="fl">0.0</span>, S);</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> rater;</span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> subject;</span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a> <span class="co">// use either uniform distribution or restricted normals</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (use_uniform_t == <span class="dv">1</span>) {</span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>    t ~ uniform(<span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>    t ~ normal(t_est, t_prior_sd);</span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (use_uniform_a == <span class="dv">1</span>) {</span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>    a ~ uniform(<span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>    a ~ normal(a_est, a_prior_sd);</span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (use_uniform_p == <span class="dv">1</span>) {</span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>    p ~ uniform(<span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>    p ~ normal(p_est, p_prior_sd);</span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a>  <span class="co">// log likelihood contribution from raters</span></span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span>:N) {</span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a>    rater = rater_index[i]; <span class="co">// rater who assigned this rating</span></span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>    subject = subject_index[i];</span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(rating[i] == <span class="dv">0</span>){ <span class="co">// assigned class 0</span></span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a>      sub_00[subject] += lpi_00[rater];</span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a>      sub_10[subject] += lpi_10[rater];</span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {           <span class="co">// assigned class 1</span></span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a>      sub_01[subject] += lpi_01[rater];</span>
<span id="cb2-100"><a href="#cb2-100" aria-hidden="true" tabindex="-1"></a>      sub_11[subject] += lpi_11[rater];</span>
<span id="cb2-101"><a href="#cb2-101" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-102"><a href="#cb2-102" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-103"><a href="#cb2-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-104"><a href="#cb2-104" aria-hidden="true" tabindex="-1"></a>  <span class="co">// accumulate by subject</span></span>
<span id="cb2-105"><a href="#cb2-105" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> eps = <span class="fl">1e-10</span>; <span class="co">// hack to avoid log(0)</span></span>
<span id="cb2-106"><a href="#cb2-106" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span>:S){</span>
<span id="cb2-107"><a href="#cb2-107" aria-hidden="true" tabindex="-1"></a>      <span class="kw">target +=</span> log_sum_exp(log(t[i] + eps) + sub_11[i] + sub_10[i],</span>
<span id="cb2-108"><a href="#cb2-108" aria-hidden="true" tabindex="-1"></a>                            log(<span class="dv">1</span>-t[i] + eps) + sub_01[i] + sub_00[i]);</span>
<span id="cb2-109"><a href="#cb2-109" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-110"><a href="#cb2-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-111"><a href="#cb2-111" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-112"><a href="#cb2-112" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</section>
<section id="machine-learning-models" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Machine Learning Models</h1>
<p>There are two traditions in thinking about rater statistics. The kappa approach is to imagine that the ratings can be chance-corrected to account for ratings that are accidentally correct. This is done via some choice of chance correction, which leads to the “zoo” of kappas, as described in <a href="./kappa.html">Chapter 3</a>. The second approach is generative in the sense that each step of the rating process is modeled in a Markov chain, meaning a sequence of probabilistic choices that lead to a rating. The t-a-p models are generative. Since “generative” is now associated with artificial intelligence, I’ll refer to these as Machine Learning (ML) models, which is a reference to the community that studies them. Training an algorithm on a large data set of annotations is a common ML task, and it’s natural to want to understand the qualities of those annotations. The ML community is familiar with the kappa approach, but I’m not sure how much the reverse is true. Part of my goal in creating this website is to translate between the two modes of thought.</p>
<p>For an overview of rater statistics from the ML tradition, see <span class="citation" data-cites="paun2018comparing">Paun et al. (<a href="#ref-paun2018comparing" role="doc-biblioref">2018</a>)</span>, where the authors describe and empirically test six methods. I’ll talk about two of these here. Both of these methods assume latent true classes for the subjects being rated, so they implicitly adopt something like a Justified True Belief approach as described in <a href="./introduction.html">Chapter 1</a>.</p>
<p>In <span class="citation" data-cites="paun2018comparing">Paun et al. (<a href="#ref-paun2018comparing" role="doc-biblioref">2018</a>)</span> the methods are described as “pooled,” meaning estimation of average parameters only, “unpooled”, meaning estimating individual rater and subject parameters, or “partially pooled,” which is a combination of the two approaches designed to take advantage of the magic of <a href="https://en.wikipedia.org/wiki/James%E2%80%93Stein_estimator">Stein Estimators</a>. For a good treatment of this idea in the Bayesian context see <span class="citation" data-cites="mcelreath2020statistical">McElreath (<a href="#ref-mcelreath2020statistical" role="doc-biblioref">2020</a>)</span>.</p>
<section id="sec-dawid-skene" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="sec-dawid-skene"><span class="header-section-number">5.1</span> Dawid &amp; Skene</h2>
<p><span class="citation" data-cites="dawid1979maximum">Dawid &amp; Skene (<a href="#ref-dawid1979maximum" role="doc-biblioref">1979</a>)</span> published what may be the first hierarchical (unpooled) moded for estimating subject and rater coefficients. In the abstract they describe the problem being addressed.</p>
<blockquote class="blockquote">
<p>In compiling a patient record many facets are subject to errors of measurement. A model is presented which allows individual error-rates to be estimated for polytomous facets even when the patient’s “true” response is not available.</p>
</blockquote>
<p>Here, “polytomous facets” means more than two possible classifications. For this discussion, I’ll only consider binary classes. Even though “true” is in scare quotes above, the model assumes that true classes <span class="math inline">\(T_i\)</span> exist. As we will see from the statistical approach here, the reference to error rates does not mean that Dawid &amp; Skene estimates rater accuracy, on the rater error rates. Since some correct answers are inaccurate (at least in the t-a-p model), the estimated rater parameters contain both accurate and inaccurate matches between the assigned and true classes of subjects. In short, Dawid &amp; Skene’s approach estimates rater distributions of assigned classes. Comparing to the classical rater agreement statistics, it’s perhaps closest to the Cohen kappa <span class="citation" data-cites="cohen1960coefficient">(<a href="#ref-cohen1960coefficient" role="doc-biblioref">Cohen, 1960</a>)</span>, which was described in <a href="./kappa.html">Chapter 3</a>. Cohen’s statistic allows each rater to have a response pattern, which is used to estimate matches at random. One additional complication with Dawid &amp; Skene’s method is that they consider multiple ratings from a rater being assigned to a single subject. This complicates the notation quite a bit, and I’ll simplify it to assume one rating per rater per subject.</p>
<p>The generation of ratings expresses the model in terms of an individual rater. For example, with <span class="math inline">\(k=2\)</span> categories a rating looks like the following.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/dawidskene.png" class="img-fluid figure-img"></p>
<figcaption>Dawid &amp; Skene sampling model for a single rating and k = 2</figcaption>
</figure>
</div>
<p>In the paper describing the method, equation 2.7 gives the likelihood of the observations. For consistency with the rest of my treatment, I’ll change the notation to correspond to the t-a-p conventions, and simplify to one observation per rater. So as before <span class="math inline">\(C_{ij}\)</span> means the annotated classication of rater <span class="math inline">\(j\)</span> of subject <span class="math inline">\(i\)</span>. Now we’ll allow <span class="math inline">\(C_{ij} \, \epsilon \{1,\dots,k\}\)</span>, corresponding to <span class="math inline">\(k\)</span> possible classifications. The <span class="math inline">\(K=2\)</span> case can be compared to what we’ve already done.</p>
<p><span class="math display">\[
Pr(\text{data; parameters}) = \prod_{i=1}^{N_s}  \left( \sum_{k=1}^K t_k \prod_{j=1}^{N_r} \prod_{l=1}^K (\pi_{kl}^{(j)})^{I(C_{ij}=l)}\right).
\]</span></p>
<p>You’ll recognize from earlier the rater distributions <span class="math inline">\(\pi_{kl}^{(j)} = Pr(\text{Rater j assigns Class l}|\text{true Class is k})\)</span>. The indicator function <span class="math inline">\(I(C_{ij}=l)\)</span> is binary, being one when the condition is true (the assigned class is <span class="math inline">\(l\)</span>) and zero otherwise. So only one of the sub-products in the innermost loop will be something other than 1, and we can rewrite the likelihood as</p>
<p><span id="eq-dawid-skene-likelihood"><span class="math display">\[
Pr(\text{data; parameters}) \sim \prod_{i=1}^{N_s}  \left( \sum_{k=1}^K t_k  \left[ \prod_{C_{ij}=1} \pi_{k1}^{(j)} \dots \prod_{C_{ij}=k}\pi_{kk}^{(j)} \right] \right).
\tag{3}\]</span></span></p>
<p>The innermost products are grouped by the assigned class, which is indexed by the subject <span class="math inline">\(i\)</span> and rater <span class="math inline">\(j\)</span>. As the authors note, this describes the likelihood of <span class="math inline">\(N_s\)</span> independent samples from a mixture of multinomial distribution with weights <span class="math inline">\(t_1 \dots t_k\)</span>. The multinomial coefficients are all factored out and discarded here, since we don’t need them to maximize likelihood.</p>
<p>The formulation of <a href="#eq-dawid-skene-likelihood" class="quarto-xref">Equation&nbsp;3</a> is the same as what we derived in <a href="#sec-likelihood" class="quarto-xref">Section&nbsp;2</a> before applying the t-a-p assumptions. See <a href="#eq-likelihood1" class="quarto-xref">Equation&nbsp;1</a>; it’s the same thing except for the binary case. The application of the t-a-p model assumptions found in <strong>?@eq-likelihood3</strong> reparameterizes the <span class="math inline">\(\pi\)</span> coefficients and reduces from three per rater (since the four <span class="math inline">\(\pi\)</span>s sum to one, there are only three free variables per rater) plus the <span class="math inline">\(t\)</span> parameter to two per rater. So the basic hierarchical t-a-p model has one fewer coefficient per rater. Dawid &amp; Skene can be translated into a hierarchical t-a-p model along the lines of the average model in <a href="./paradox.html">Chapter 4</a> where the accuracy and random assignment parameters split to be conditioned on the true class. It’s possible to use the Dawid &amp; Skene approach while retaining a parameter for rater accuracy (two of them in this case), e.g.&nbsp;with a Stan script.</p>
<p>Bob Carpenter’s Stan code from <span class="citation" data-cites="paun2018comparing">Paun et al. (<a href="#ref-paun2018comparing" role="doc-biblioref">2018</a>)</span> is here:</p>
<details>
<summary>
View Stan code
</summary>
<div class="sourceCode" id="cb3"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>&gt; J; <span class="co">//number of annotators</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">2</span>&gt; K; <span class="co">//number of classes</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>&gt; N; <span class="co">//number of annotations</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>&gt; I; <span class="co">//number of items</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>,<span class="kw">upper</span>=I&gt; ii[N]; <span class="co">//the item the n-th annotation belongs to</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>,<span class="kw">upper</span>=J&gt; jj[N]; <span class="co">//the annotator which produced the n-th annotation</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> y[N]; <span class="co">//the class of the n-th annotation</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="kw">transformed data</span> {</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vector</span>[K] alpha = rep_vector(<span class="dv">1</span>,K); <span class="co">//class prevalence prior</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vector</span>[K] eta = rep_vector(<span class="dv">1</span>,K); <span class="co">//annotator abilities prior</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="kw">parameters</span> {</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">simplex</span>[K] pi;</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">simplex</span>[K] beta[J,K];</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="kw">transformed parameters</span> {</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vector</span>[K] log_q_c[I];</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vector</span>[K] log_pi;</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vector</span>[K] log_beta[J,K];</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>  log_pi = log(pi);</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>  log_beta = log(beta);</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) </span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    log_q_c[i] = log_pi;</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (n <span class="cf">in</span> <span class="dv">1</span>:N) </span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (h <span class="cf">in</span> <span class="dv">1</span>:K)</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>      log_q_c[ii[n],h] = log_q_c[ii[n],h] + log_beta[jj[n],h,y[n]];</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a><span class="kw">model</span> {</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span>:J)</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(h <span class="cf">in</span> <span class="dv">1</span>:K)</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>      beta[j,h] ~ dirichlet(eta);</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>  pi ~ dirichlet(alpha);</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I)</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">target +=</span> log_sum_exp(log_q_c[i]);</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a><span class="kw">generated quantities</span> {</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vector</span>[K] q_z[I]; <span class="co">//the true class distribution of each item</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span>:I)</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>    q_z[i] = softmax(log_q_c[i]);</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>See p.&nbsp;573 of <span class="citation" data-cites="paun2018comparing">Paun et al. (<a href="#ref-paun2018comparing" role="doc-biblioref">2018</a>)</span> for a “partially pooled” variation of the Dawid &amp; Skene method.</p>
<blockquote class="blockquote">
<p>This structure [uses] information about the population to improve estimates of individuals by regularizing toward the population mean. This is particularly helpful with low count data as found in many crowdsourcing tasks</p>
</blockquote>
</section>
<section id="sec-mace" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="sec-mace"><span class="header-section-number">5.2</span> MACE</h2>
<p>The MACE algorithm is newer rater aggreement approach from the machine learning community. It was introduced in <span class="citation" data-cites="hovy2013learning">Hovy et al. (<a href="#ref-hovy2013learning" role="doc-biblioref">2013</a>)</span>, where we find a description of the model’s annotation (rating) generation process.</p>
<blockquote class="blockquote">
<p>We assume that an annotator always produces the correct label when he tries to. […] Our model generates the observed annotations as follows: First, for each instance <span class="math inline">\(i\)</span>, we sample the true label <span class="math inline">\(T_i\)</span> from a uniform prior. Then for each annotator <span class="math inline">\(j\)</span>, we draw a binary variable <span class="math inline">\(S_{ij}\)</span> from a Bernoulli distribution with parameter <span class="math inline">\(1 - \theta_j\)</span>. <span class="math inline">\(S_{ij}\)</span> represents whether or not an annotator <span class="math inline">\(j\)</span> is spamming on instance <span class="math inline">\(i\)</span>. We assume that when an annotator is not spamming on an instance, i.e.&nbsp;<span class="math inline">\(S_{ij}=0\)</span>, he just copies the true value to produce annotation <span class="math inline">\(A_{ij}\)</span>. If <span class="math inline">\(S_{ij}=1\)</span>, we say that the annotator is spamming on the current instance, and <span class="math inline">\(A_{ij}\)</span> is sampled from a multinomial with parameter vector <span class="math inline">\(\xi_j\)</span>. Note that in this case the annotation <span class="math inline">\(A_{ij}\)</span> <em>does not</em> depend on the true label <span class="math inline">\(T_i\)</span>.</p>
</blockquote>
<p>It’s straightforward to translate this into the t-a-p notation., where we assume there are only two annotations (ratings), a 0 or 1.</p>
<ul>
<li><p>The subjects are indexed by <span class="math inline">\(i = 1 \dots N\)</span> and raters/annotators indexed by <span class="math inline">\(j = 1 \dots M\)</span> in the MACE description. For t-a-p, we’re using <span class="math inline">\(N_s\)</span> for number of subjects and <span class="math inline">\(N_r\)</span> for raters, and a total of <span class="math inline">\(N\)</span> ratings.</p></li>
<li><p><span class="math inline">\(T_i\)</span> is the true class in both descriptions</p></li>
<li><p><span class="math inline">\(C_{ij}\)</span>, the set of <span class="math inline">\(N\)</span> ratings/classifications/annotations in MACE becomes <span class="math inline">\(A_{ij}\)</span>.</p></li>
<li><p><span class="math inline">\(A_{ij}\)</span> in the t-a-p model is the binary indication of an accurate rating, which is <span class="math inline">\(\bar{S}_{ij} = 1 - S_{ij}\)</span> in MACE. Spamming is the opposite (complement) of accuracy.</p></li>
<li><p>Average rater accuracy <span class="math inline">\(a_j\)</span> is <span class="math inline">\(\theta_j\)</span> in the MACE paper.</p></li>
<li><p>The random assignment probability for a rater <span class="math inline">\(p_j\)</span> is <span class="math inline">\(\xi_j\)</span> in MACE.</p></li>
</ul>
<p>The MACE algorithm captures all the elements of Justified True Belief, with latent truth and rater accuracy, just slightly reformulated. So MACE is the same as the hierarchical t-a-p model. I didn’t know any of this when I started developing the t-a-p model from the kappa tradition, but obviously the credit for invention goes to the MACE authors, who published this in 2013.</p>
<p>The likelihood function given in <span class="citation" data-cites="hovy2013learning">Hovy et al. (<a href="#ref-hovy2013learning" role="doc-biblioref">2013</a>)</span> can be translated into the t-a-p model notation as</p>
<p><span id="eq-mace"><span class="math display">\[
\begin{aligned}
Pr(C;t,a,p) &amp;= \sum_{T,A} \left[ \prod_{i}  Pr(T_i) \prod_{j}  Pr(A_{ij}; a_j) Pr(C_{ij} | A_{ij},T_i;p_j)\right] \\
\end{aligned}
\tag{4}\]</span></span></p>
<p>where I’ve recast the product into the more compact <span class="math inline">\(\pi\)</span> coefficients from Dawid &amp; Skene, and assume binary classifications. All I can figure is that the first line in the paper has a typo reversing the outer sum with the product over <span class="math inline">\(i\)</span>, and it should be written as</p>
<p><span id="eq-mace-fixed"><span class="math display">\[
\begin{aligned}
Pr(C;t,a,p) &amp;=  \prod_{i}  Pr(T_i) \sum_{T,A}\prod_{j}  Pr(A_{ij}; a_j) Pr(C_{ij} | A_{ij},T_i;p_j) \\
&amp;= \prod_{i}\left( t_i \prod_{j} \pi_{1C_{ij}}^{(j)} + \bar{t}_i \prod_{j} \pi_{0C_{ij}}^{(j)} \right) .
\end{aligned}
\tag{5}\]</span></span></p>
<p>The second line is the earlier derivation, matching the Dawid &amp; Skene likelihood. The next step is to apply the t-a-p reparameterization to the <span class="math inline">\(\pi\)</span> coefficients. Unlike the Dawid &amp; Skene paper, there’s no derivation of the likelihood formula, and the meaning of the sum over <span class="math inline">\(T\)</span> and <span class="math inline">\(A\)</span> is not clear. I assume it’s over the <em>values</em> that these parameters can take, not the empirical vectors of values themselves. In any case, the likelihood is expressed as a sum of products in <a href="#eq-mace" class="quarto-xref">Equation&nbsp;4</a>, which is different from the t-a-p derivation above, which is a product of sums.</p>
<p>Bob Carpenter’s Stan code for implenting MACE <span class="citation" data-cites="paun2018comparing">(<a href="#ref-paun2018comparing" role="doc-biblioref">Paun et al., 2018</a>)</span> matches the <a href="#eq-mace-fixed" class="quarto-xref">Equation&nbsp;5</a> version. I have changed the array declarations to conform with the latest version of Stan (which broke old code) and added comments to annotate how the variables match to the t-a-p nomenclature. This code, as MACE is, is designed for multiple classes (more than 2), but I’ve described in the binary case. In that case, the algorithm assumes initially that <span class="math inline">\(t=.5\)</span> as a way to generate the parameters we call <span class="math inline">\(a_j\)</span> and <span class="math inline">\(p_j\)</span>, which then allow refined estimation of <span class="math inline">\(t_i\)</span>.</p>
<details>
<summary>
View MACE Stan code
</summary>
<div class="sourceCode" id="cb4"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>&gt; J; <span class="co">//number of annotators</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">2</span>&gt; K; <span class="co">//number of classes</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>&gt; N; <span class="co">//number of annotations</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>&gt; I; <span class="co">//number of items</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>,<span class="kw">upper</span>=I&gt; ii[N]; <span class="co">//the item the n-th annotation belongs to</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">1</span>,<span class="kw">upper</span>=J&gt; jj[N]; <span class="co">//the annotator which produced the n-th annotation</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> y[N]; <span class="co">//the class of the n-th annotation</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="kw">transformed data</span> {</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vector</span>[K] alpha = rep_vector(<span class="fl">1.0</span>/K,K);</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vector</span>[K] eta = rep_vector(<span class="dv">10</span>,K);</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="kw">parameters</span> {</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">simplex</span>[K] epsilon[J];</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>, <span class="kw">upper</span>=<span class="dv">1</span>&gt; theta[J];</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="kw">transformed parameters</span> {</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vector</span>[K] log_q_c[I];</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vector</span>[K] log_alpha;</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>  log_alpha = log(alpha);</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I) </span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    log_q_c[i] = log_alpha;</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (n <span class="cf">in</span> <span class="dv">1</span>:N) </span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (h <span class="cf">in</span> <span class="dv">1</span>:K)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span> indicator = (y[n] == h);</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>      log_q_c[ii[n],h] = log_q_c[ii[n],h] + log( theta[jj[n]] * indicator + (<span class="dv">1</span>-theta[jj[n]]) * epsilon[jj[n],y[n]] );</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a><span class="kw">model</span> {</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span>:J)</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    epsilon[j] ~ dirichlet(eta);</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>    theta[j] ~ beta(<span class="fl">0.5</span>,<span class="fl">0.5</span>);</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span>:I)</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">target +=</span> log_sum_exp(log_q_c[i]);</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a><span class="kw">generated quantities</span> {</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vector</span>[K] q_z[I]; <span class="co">//the true class distribution of each item</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span>:I)</span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>    q_z[i] = softmax(log_q_c[i]);</span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</section>
</section>
<section id="groupthink" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Groupthink</h1>
<p>In the discussion of the Fleiss kappa in <a href="./kappa.html">Chapter 3</a>, I noted that the assumption that <span class="math inline">\(p=t\)</span> might imply that knowlege about the true class rate affects rater assignments, which could violate the independence assumption. For example, a rare condition might be ignored because it’s improbable. This knowlege leakage is inevitable with human raters, and the ratings may be better understood as independent conditional on some set of shared beliefs and contexts. Suppose we push this idea by assuming that each rater’s random assignment rate for Class 1 for <em>each subject</em> is the prevalence of ratings for that subject. This could happen if raters talk to each other and take a straw poll before assigning their ratings. In this case, <span class="math inline">\(p\)</span> can be indexed to subjects as <span class="math inline">\(p_i = c_i\)</span>, so we could call the hierarchical model <span class="math inline">\(t_i-a_j-c_i\)</span>. This is the Fleiss assumption, but instead of applied to the whole set of ratings, it’s within each subject. If a rater classifies inaccurately, the class assignment is influenced by the group’s collective opinion, which we might call groupthink.</p>
<p>The effect of this non-independence is a dramatic reduction in our ability to estimate rater accuracy. A simple way to test this is to modify the average t-a-p model to inject the average Class 1 rate into the <span class="math inline">\(p_j\)</span> parameter (so <span class="math inline">\(p_j = c_i\)</span>) and then find the maximum likelihood.</p>
<details>
<summary>
View Stan code
</summary>
<div class="sourceCode" id="cb5"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">//   A Groupthink t_i-a_j-c_i model</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">//   The development is described in the hierarchical chapter under Groupthink</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Learn more about model development with Stan at:</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">//    http://mc-stan.org/users/interfaces/rstan.html</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">//    https://github.com/stan-dev/rstan/wiki/RStan-Getting-Started</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">// The ratings summary (number of 1-ratings per case) and descriptives</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> {</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; N;   <span class="co">// number of ratings</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; S;   <span class="co">// number of subjects being rated</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; R;   <span class="co">// number of unique raters</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[N] <span class="dt">int</span> rating;        <span class="co">// array of binary ratings</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[N] <span class="dt">int</span> subject_index; <span class="co">// the ID of the subject for the ith rating. Should be in 1:S</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[N] <span class="dt">int</span> rater_index; <span class="co">// the ID of the rater for the ith rating. Should be in 1:R</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[S] <span class="dt">real</span> p; <span class="co">// average number of Class 1 ratings for subject i</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="co">// The parameters to estimate</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="kw">parameters</span> {</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">// random effects</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span> = <span class="dv">0</span>, <span class="kw">upper</span> = <span class="dv">1</span>&gt; a;  <span class="co">// rater random parameter</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span>&lt;<span class="kw">lower</span> = <span class="dv">0</span>, <span class="kw">upper</span> = <span class="dv">1</span>&gt; t; <span class="co">// the estimated true class probability for subjects</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a><span class="co">// The model to be estimated.</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a><span class="kw">model</span> {</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>  <span class="co">// accumulation of log likelihood by subject</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[S] <span class="dt">real</span> sub_00 = rep_array(<span class="fl">0.0</span>, S);</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[S] <span class="dt">real</span> sub_01 = rep_array(<span class="fl">0.0</span>, S);</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[S] <span class="dt">real</span> sub_10 = rep_array(<span class="fl">0.0</span>, S);</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[S] <span class="dt">real</span> sub_11 = rep_array(<span class="fl">0.0</span>, S);</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> subject;</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> lpi_00; <span class="co">// Pr(Assigned class = 0 | True class = 0)</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> lpi_01;</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> lpi_10;</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> lpi_11;</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> p_;</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> eps = <span class="fl">1e-10</span>; <span class="co">// hack to avoid log(0)</span></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>  <span class="co">// priors for average params</span></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>  t ~ uniform(<span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>  a ~ uniform(<span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>  <span class="co">// log likelihood contribution from raters</span></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span>:N) {</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>    subject = subject_index[i];</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>    p_ = p[subject]; <span class="co">// from the data, equals avg class 1 rating for subject</span></span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">// likelihoods</span></span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>    lpi_00 = log(<span class="dv">1</span>-(<span class="dv">1</span>-a)*p_ + eps);</span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>    lpi_01 = log((<span class="dv">1</span>-a)*(<span class="dv">1</span>-p_) + eps);</span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>    lpi_10 = log((<span class="dv">1</span>-a)*p_ + eps);</span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>    lpi_11 = log(a + (<span class="dv">1</span>-a)*p_ + eps);</span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(rating[i] == <span class="dv">0</span>){ <span class="co">// assigned class 0</span></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>      sub_00[subject] += lpi_00;</span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>      sub_10[subject] += lpi_10;</span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {           <span class="co">// assigned class 1</span></span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>      sub_01[subject] += lpi_01;</span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>      sub_11[subject] += lpi_11;</span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a>  <span class="co">// accumulate by subject</span></span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span>:S){</span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a>      <span class="kw">target +=</span> log_sum_exp(log(t + eps) + sub_11[i] + sub_10[i],</span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a>                            log(<span class="dv">1</span>-t + eps) + sub_01[i] + sub_00[i]);</span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>The simulation here is an easy problem to solve with all three of the t-a-p parameters set to .7. The model estimates for accuracy are around .06 instead of .7.</p>
<div class="cell">
<details class="code-fold">
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tapModel)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(LaplacesDemon) <span class="co"># for mode and rbern</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>refresh <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(refresh){</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># simulate hierarchical data and compare fit</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  n_sim <span class="ot">=</span> <span class="dv">30</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  n_subjects <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>  n_raters <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>  true <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>  direct1 <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>  mcmc1 <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>  stan_model <span class="ot">&lt;-</span> <span class="st">"code/t-a-c_i.stan"</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>  compiled_model <span class="ot">&lt;-</span> cmdstanr<span class="sc">::</span><span class="fu">cmdstan_model</span>(stan_model)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>  sim_results <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_sim){</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># simulate data</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    sim_param_list <span class="ot">=</span> <span class="fu">list</span>( <span class="at">t =</span> <span class="fu">runif</span>(n_subjects)<span class="sc">/</span><span class="dv">5</span> <span class="sc">+</span> .<span class="dv">7</span> <span class="sc">-</span> .<span class="dv">1</span>,</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>                       <span class="at">a =</span> <span class="fu">runif</span>(n_raters)<span class="sc">/</span><span class="dv">5</span> <span class="sc">+</span> .<span class="dv">7</span> <span class="sc">-</span> .<span class="dv">1</span>,</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>                       <span class="at">p =</span> <span class="fu">runif</span>(n_raters)<span class="sc">/</span><span class="dv">5</span> <span class="sc">+</span> .<span class="dv">7</span> <span class="sc">-</span> .<span class="dv">1</span>)</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    ratings <span class="ot">&lt;-</span> <span class="fu">generate_ti_aj_pj_ratings</span>(<span class="at">param_list =</span> sim_param_list)</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># empirical averages for true params</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>    true_subjects <span class="ot">&lt;-</span> ratings <span class="sc">|&gt;</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>      <span class="fu">group_by</span>(subject_id) <span class="sc">|&gt;</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>      <span class="fu">summarize</span>(<span class="at">t =</span> <span class="fu">mean</span>(T_i)) <span class="co"># should be 0 or 1</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>    true_raters <span class="ot">&lt;-</span> ratings <span class="sc">|&gt;</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>      <span class="fu">group_by</span>(rater_id) <span class="sc">|&gt;</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>      <span class="fu">summarize</span>(<span class="at">a =</span> <span class="fu">mean</span>(A_ij),</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>                <span class="at">p =</span> <span class="fu">mean</span>(<span class="fu">if_else</span>(A_ij <span class="sc">==</span> <span class="dv">1</span>, <span class="cn">NA</span>, P_ij), <span class="at">na.rm =</span> <span class="cn">TRUE</span>))</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># closed form estimation</span></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>    rating_params <span class="ot">&lt;-</span> tapModel<span class="sc">::</span><span class="fu">fit_ratings</span>(ratings)</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>    param_list <span class="ot">&lt;-</span> <span class="fu">pull_rating_params</span>(rating_params)</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>    c_i <span class="ot">&lt;-</span> rating_params <span class="sc">|&gt;</span> </span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>           <span class="fu">group_by</span>(subject_id) <span class="sc">|&gt;</span> </span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>           <span class="fu">summarize</span>(<span class="at">c_i =</span> <span class="fu">mean</span>(rating))</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># mcmc model using Carpenter MACE</span></span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>    mcmc <span class="ot">&lt;-</span> compiled_model<span class="sc">$</span><span class="fu">sample</span>(</span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>      <span class="at">data =</span> <span class="fu">list</span>(</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>        <span class="at">N =</span> <span class="fu">nrow</span>(rating_params),</span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>        <span class="at">S =</span> <span class="fu">n_distinct</span>(rating_params<span class="sc">$</span>subject_id),</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>        <span class="at">R =</span> <span class="fu">n_distinct</span>(rating_params<span class="sc">$</span>rater_id),</span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>        <span class="at">rating =</span> rating_params<span class="sc">$</span>rating,</span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>        <span class="at">subject_index =</span> rating_params<span class="sc">$</span>subject_id,</span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>        <span class="at">rater_index =</span> rating_params<span class="sc">$</span>rater_id,</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>        <span class="at">p =</span> c_i<span class="sc">$</span>c_i),</span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>      <span class="at">seed =</span> <span class="dv">123</span>,</span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>      <span class="at">chains =</span> <span class="dv">3</span>,</span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>      <span class="at">parallel_chains =</span> <span class="dv">3</span>,</span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a>      <span class="at">iter_warmup =</span> <span class="dv">200</span>,</span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a>      <span class="at">refresh =</span> <span class="dv">1000</span>)</span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a>    sim_results[[i]] <span class="ot">&lt;-</span> tapModel<span class="sc">::</span><span class="fu">estimate_params_mcmc</span>(mcmc<span class="sc">$</span><span class="fu">draws</span>()) </span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a>  all_results <span class="ot">&lt;-</span> <span class="fu">do.call</span>(rbind, <span class="fu">lapply</span>(<span class="fu">seq_along</span>(sim_results), <span class="cf">function</span>(i) {</span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true" tabindex="-1"></a>    df <span class="ot">&lt;-</span> sim_results[[i]]</span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true" tabindex="-1"></a>    df<span class="sc">$</span>sim <span class="ot">&lt;-</span> i</span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true" tabindex="-1"></a>    df</span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true" tabindex="-1"></a>  }))</span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true" tabindex="-1"></a>  <span class="fu">write_rds</span>(all_results, <span class="st">"data/groupthink.rds"</span>)</span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true" tabindex="-1"></a>  all_results <span class="ot">&lt;-</span> <span class="fu">read_rds</span>(<span class="st">"data/groupthink.rds"</span>)</span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-84"><a href="#cb6-84" aria-hidden="true" tabindex="-1"></a><span class="co"># plot accuracy estimates</span></span>
<span id="cb6-85"><a href="#cb6-85" aria-hidden="true" tabindex="-1"></a>all_results <span class="sc">|&gt;</span> </span>
<span id="cb6-86"><a href="#cb6-86" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(var <span class="sc">==</span> <span class="st">"a"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb6-87"><a href="#cb6-87" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> avg)) <span class="sc">+</span></span>
<span id="cb6-88"><a href="#cb6-88" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_density</span>(<span class="at">fill =</span> <span class="st">"steelblue"</span>) <span class="sc">+</span></span>
<span id="cb6-89"><a href="#cb6-89" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb6-90"><a href="#cb6-90" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlim</span>(<span class="dv">0</span>,<span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb6-91"><a href="#cb6-91" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_vline</span>(<span class="at">xintercept =</span> <span class="fl">0.7</span>, <span class="at">linetype =</span> <span class="st">"dashed"</span>, <span class="at">color =</span> <span class="st">"red"</span>) <span class="sc">+</span></span>
<span id="cb6-92"><a href="#cb6-92" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"Average Rater Accuracy"</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="hierarchical_files/figure-html/groupthink-sim-1.png" class="img-fluid figure-img" width="336"></p>
<figcaption>Simulation results with t-a-p parameters set to .7 and using the groupthink assumption that p_j = c_i. The density of the estimates for average accuracy are plotted with the true value as a dashed line.</figcaption>
</figure>
</div>
</div>
</div>
<p>The lesson here is that non-independence, where the raters have a consensus-building process or just a per-subject referent, makes estimating rater accuracy difficult. For more on testing for non-independence, see <a href="./fit.html">Chapter 6</a>.</p>
</section>
<section id="invariant-scales" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Invariant Scales</h1>
<p>Educational testing has evolved methods like <a href="https://en.wikipedia.org/wiki/Item_response_theory">Item Response Theory</a> (IRT) for simultaneously estimating student ability and test item difficulty. We can compare the standard three-parameter model to the t-a-p model by naming the parameters analogously. Assume it’s a binary (True/False) test for simplicity. For a given test item (think: subject to be rated) there is a true answer <span class="math inline">\(T_i\)</span> and test-taker (rater) classification <span class="math inline">\(C_{ij}\)</span>. Each test-taker <span class="math inline">\(j\)</span> has an intrisic ability to get items correct <span class="math inline">\(\alpha_j\)</span>, which is a real value on <span class="math inline">\((-\infty,+\infty)\)</span>, usually assumed to be normally distributed over a population. Each test item has an intrisic bias difficulty <span class="math inline">\(d_i\)</span> on the same (invariant) scale. The difficulty works against ability, so we’ll be interested in <span class="math inline">\(a_j - d_i\)</span> as a chance of getting the correct answer. The probability of getting the correct answer depends on both the test-taker (rater) and the item (subject), with</p>
<p><span class="math display">\[
Pr[C_{ij} = T_i] = \frac{1}{1 + e^{-s_i(\alpha_j - d_i)}},
\]</span></p>
<p>where <span class="math inline">\(s_i\)</span> a steepness parameter for the sigmoid, called <em>discrimination</em>. This allows the slope of the logistic curve to vary at its steepest point by test item.</p>
<p>In practice, this condition is fitted using a binomial regression on the log-odds scale, so that</p>
<p><span class="math display">\[
\log \left(\frac{Pr[C_{ij} = T_i]}{1 - Pr[C_{ij} = T_i]}\right) = s_i(\alpha_j - d_i).
\]</span> In one variation, there is a probability of getting the correct answer <span class="math inline">\(q_i\)</span> by chance, which depends on the item (subject) rather than on the test-taker. I’ll use <span class="math inline">\(q\)</span> instead of <span class="math inline">\(p\)</span> because we used <span class="math inline">\(p_j\)</span> for the chance of randomly picking Class 1 for inaccurate ratings, which is different from randomly picking the true class. Rather than the hard switch of a Bernoulli trial (i.e.&nbsp;a uniform distribution with a cut-off to determine 0 or 1) to determine an accurate response, as in the t-a-p model, IRT uses a sigmoid function as a soft switch between accurate and inaccurate classification. The simplest version, without the difficulty and discrimination parameters, looks like</p>
<p><span class="math display">\[
\begin{aligned}
Pr[C_{ij} = T_i] &amp;= q_i + \bar{q}_i \alpha_j,  \\
\end{aligned}
\]</span></p>
<p>Where <span class="math inline">\(\alpha_j\)</span> would be estimated as a log-odds latent variable. When the latent variable is a large negative number (low ability), the probability of a correct response tends to <span class="math inline">\(q_i\)</span>, pure guessing. We can compare this formulation to the three-parameter t-a-p model, (suppressing the indices) as</p>
<p><span class="math display">\[
\begin{aligned}
q + \bar{q} a  &amp;=  t\bar{a}p + \bar{t}\bar{a}\bar{p} + a.\\
\end{aligned}
\]</span> The key idea from IRT that we can apply to the t-a-p models is the use of latent scales instead of direct probabilities for the parameters. If we want to consider that some subjects are more difficult to classify than others, we could follow the IRT model and use a difficulty parameter <span class="math inline">\(d_i\)</span> for each subject, so that the probability of correct classification is something like <span class="math inline">\(a_j - d_i\)</span>. That won’t work if <span class="math inline">\(a\)</span> and <span class="math inline">\(d\)</span> are both probabilities, because we’ll get negative numbers if <span class="math inline">\(d_i &gt; a_j\)</span>. The IRT solution is to use a sigmoid function like the logistic above to map these parameters on the real line as latent variables. The philosophical cost is that we must assume that they have the same dimension, which permits scalar operations.</p>
<p>Is difficulty the same thing as accuracy? In some cases this seems justified. Suppose we’re asking raters to classify images of dogs or non-dogs (like in a Captcha). There are ways in which images can be generally degraded, e.g.&nbsp;being out of focus or only containing part of the dog in the picture. In this case, the difficulty of the image is would seem to decrease accuracy in a plausibly general manner.</p>
<p>This idea can be generalized. If raters are college professors reporting on the quality of student writing, we might suppose that accuracy is related to how long a professor has been teaching and perhaps to their academic discipline. Maybe English professors can judge writing better than Engineers. Using latent scales, we could propose a model where accuracy is affected by (1) individual rater ability to judge writing <span class="math inline">\(a_j\)</span>, (2) the student being rated <span class="math inline">\(d_j\)</span>, and (3) the rater’s experience, measured in years <span class="math inline">\(y_j\)</span>. Then the accuracy parameter depends on both the rater and subject as</p>
<p><span class="math display">\[
a_{ij} = \frac{1}{1 + e^{-(\alpha_j - \delta_i + \eta y_j)}},
\]</span> where <span class="math inline">\(\alpha\)</span> is the latent accuracy parameter, <span class="math inline">\(\delta\)</span> is the difficulty latent parameter, and <span class="math inline">\(\eta\)</span> (eta, for experience) is a parameter that measures the effect of experience on accuracy and converts years to the same units as the other parameters.</p>
</section>
<section id="partial-pooling" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> Partial Pooling</h1>
<p>Another feature of the latent scale for parameters is that we can easily combine average and individual effects. For example, we can use the average accuracy of all raters to estimate the accuracy of a new rater. This is called “partial pooling” in the Bayesian literature, and it works by estimating the average parameters from a large data set and then using them to estimate the individual parameters. The idea is that we can borrow strength from the population to improve our estimates of individual parameters. The simplest case looks like</p>
<p><span class="math display">\[
a_j = \frac{1}{1 + e^{-(\alpha + \alpha_j)}},
\]</span> where <span class="math inline">\(a\)</span> is the average accuracy of all raters, and the <span class="math inline">\(a_j\)</span> parameters are considered “random effects” in that they are given a prior distribution that is also fitted by the MCMC algorithm. A common choice would be <span class="math inline">\(a_j \epsilon N(0, \sigma_a)\)</span>, where <span class="math inline">\(\sigma_a\)</span> is a standard deviation parameter that is also estimated. This is a normal distribution with mean 0 and standard deviation <span class="math inline">\(\sigma_a\)</span>. The <span class="math inline">\(a_j\)</span> parameters are then estimated as deviations from the average accuracy <span class="math inline">\(a\)</span>, and the maximum likelihood estimation will determine how much of the variance in the <span class="math inline">\(a_j\)</span> parameters is due to the average accuracy. This is a common approach in Bayesian statistics, and it works well when the data is normally distributed. The t-a-p model can be modified to include partial pooling for both the <span class="math inline">\(a_j\)</span> and <span class="math inline">\(p_j\)</span> parameters.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" data-line-spacing="2" role="list">
<div id="ref-agresti2003categorical" class="csl-entry" role="listitem">
Agresti, A. (2003). <em>Categorical data analysis</em> (Vol. 482). John Wiley &amp; Sons.
</div>
<div id="ref-cohen1960coefficient" class="csl-entry" role="listitem">
Cohen, J. (1960). A coefficient of agreement for nominal scales. <em>Educational and Psychological Measurement</em>, <em>20</em>(1), 37–46.
</div>
<div id="ref-dawid1979maximum" class="csl-entry" role="listitem">
Dawid, A. P., &amp; Skene, A. M. (1979). Maximum likelihood estimation of observer error-rates using the EM algorithm. <em>Journal of the Royal Statistical Society: Series C (Applied Statistics)</em>, <em>28</em>(1), 20–28.
</div>
<div id="ref-gelman2006data" class="csl-entry" role="listitem">
Gelman, A., &amp; Hill, J. (2006). <em>Data analysis using regression and multilevel/hierarchical models</em>. Cambridge university press.
</div>
<div id="ref-hovy2013learning" class="csl-entry" role="listitem">
Hovy, D., Berg-Kirkpatrick, T., Vaswani, A., &amp; Hovy, E. (2013). Learning whom to trust with MACE. <em>Proceedings of the 2013 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies</em>, 1120–1130.
</div>
<div id="ref-mcelreath2020statistical" class="csl-entry" role="listitem">
McElreath, R. (2020). <em>Statistical rethinking: A bayesian course with examples in r and stan</em> (2nd ed.). Chapman; Hall/CRC.
</div>
<div id="ref-paun2018comparing" class="csl-entry" role="listitem">
Paun, S., Carpenter, B., Chamberlain, J., Hovy, D., Kruschwitz, U., &amp; Poesio, M. (2018). Comparing bayesian models of annotation. <em>Transactions of the Association for Computational Linguistics</em>, <em>6</em>, 571–585.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/kappazoo\.com\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>