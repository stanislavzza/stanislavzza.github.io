<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="David Eubanks">

<title>Chapter 4: Hierarchical Models – The Kappa Zoo</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">The Kappa Zoo</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#binary-truth" id="toc-binary-truth" class="nav-link" data-scroll-target="#binary-truth"><span class="header-section-number">2</span> Binary Truth</a></li>
  <li><a href="#probability-instead-of-truth" id="toc-probability-instead-of-truth" class="nav-link" data-scroll-target="#probability-instead-of-truth"><span class="header-section-number">3</span> Probability Instead of Truth</a></li>
  <li><a href="#a-em-approach" id="toc-a-em-approach" class="nav-link" data-scroll-target="#a-em-approach"><span class="header-section-number">4</span> A EM Approach</a></li>
  <li><a href="#model-notation" id="toc-model-notation" class="nav-link" data-scroll-target="#model-notation"><span class="header-section-number">5</span> Model Notation</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="hierarchical.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Chapter 4: Hierarchical Models</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>David Eubanks </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>We’ve seen how adding parameters to the simple kappa models leads to more general t-a-p models. Adding more parameters is possible to generate details that are hidden by averaging. The Cohen Kappa is an old example of this, where each rater has a different <span class="math inline">\(p\)</span> probability of guessing correctly.</p>
<p>This idea can be expanded, for example to simultaneously estimate the accuracy of each rater and classification of subject individually. Such models are sometimes called hierarchical or random effects models or fixed effects models, depending on the research tradition. (As noted in <span class="citation" data-cites="agresti2003categorical">@agresti2003categorical</span>, p.&nbsp;523 and <span class="citation" data-cites="gelman2006data">@gelman2006data</span>, p.&nbsp;245, fixed versus random effects are not good descriptions for Bayesian models.) What these larger models have in common is that they allow for complex relationships of average and individual parameters, for example having a grand average accuracy parameter <span class="math inline">\(a\)</span> in addition to individual accuracy parameters <span class="math inline">\(a_j\)</span> for each rater <span class="math inline">\(j\)</span>. In a Bayesian context, we can do “partial pooling” by allowing the scale (standard deviation) of the <span class="math inline">\(a_j\)</span> parameters to be estimated from the data, rather than fixed at a constant value. This allows the model to estimate the degree to which the raters are similar to each other, and to the grand average, which can increase likelihood, producing better model fit.</p>
<p>Individual rater parameters and subject truth values are of interest in many contexts. In educational psychology, we might want to know how well a teacher is able to assess student learning, and how well the students demonstrate knowledge or skill. In medical research, we might want to know how well a doctor is able to diagnose a disease, and how well the patients are responding to treatment. In machine learning, we may be concerned with the quality of training data drawn from human classifications. The ratings of consumer products on sites like Amazon or Yelp can be polluted with unfaithful reviews, so some means of detection is valuable.</p>
<p>Allowing for each rater to have an accuracy parameter is straightforward, but the truth value of each subject is more complicated. For concreteness, consider a model where each subject has a true classification <span class="math inline">\(T_i\)</span> of Class 1 or Class 0, and each rater has an accuracy parameter <span class="math inline">\(a_j\)</span>. Finally, suppose the <span class="math inline">\(p\)</span> “guessing” parameter is treated as a nuisanse coefficient with a fixed scalar <span class="math inline">\(p\)</span>. Using the tree diagram, we can write the conditional probabilities for each rating of Class 1 as <span class="math inline">\(Pr[C_{ij} = 1] = T_ia_j + \bar{a_j}p\)</span> and hence <span class="math inline">\(Pr[C_{ij} = 0] = 1 - T_ia_j - \bar{a_j}p\)</span>. For independent observations, the log likelihood function can then be updated by summing over</p>
<p><span class="math display">\[
L = -\sum_{i,j} \left[ C_{ij}\log(T_ia_j + \bar{a_j}p) + \bar{C_{ij}}\log(1 - T_ia_j - \bar{a_j}p) \right]
\]</span>In the notation, capital letters are used for binary variables and lower case for scalars, which are usually in <span class="math inline">\([0,1]\)</span>. The <span class="math inline">\(C_{ij}\)</span> values are the observations (the data from the ratings), so that only one of the summands in the expression will be non-zero at a time, depending on whether the rating was Class 1 or Class 0. The <span class="math inline">\(T_i\)</span> values are the unknown true classifications, which can only be 1 or 0, for Class 1 or Class 0.</p>
</section>
<section id="binary-truth" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Binary Truth</h1>
<p>So far we have treated truth as a metaphysical property of each subject: we’ve assumed an unknown true classification for each subject. This assumption makes the general t-a-p model easy to analyze by using binomial mixtures because we only need to estimate the <em>fraction</em> of true Class 1 cases.</p>
<p>In the derivation of the t-a-p model we used <span class="math inline">\(T_i\)</span> to denote the true binary classification of subject <span class="math inline">\(i\)</span>, and <span class="math inline">\(t\)</span> to denote the proportion of subjects that are Class 1. The <span class="math inline">\(t\)</span> parameter became the mixture weight (a scalar) in the binomial mixture model. This presented no computational challenges, because each of the three parameters is a scalar in <span class="math inline">\([0,1]\)</span>, and the likelihood function is differentiable.</p>
<p>To estimate individual rater accuracy using metaphysical truth, we have to deal with binary values in the function, which means it cannot be differentiated. This is a problem for many optimization algorithms, which require smoothness to find a maximum value. One work-around is to use a threshold function, as is used in logistic regression, neural nets, and so forth. This corresponds to the idea from psychological measurement, where a “latent” variable is allowed to have real values, usually with a normal distribution centered at zero, but the value is not directly observed or measured. For example, we might imagine that college students have an abstract trait of “writing ability” that is approximately normally distributed over the universe of students. We then convert from the latent scale to an approximation of a discrete one by applying a threshold function <span class="math inline">\(\tau\)</span> like the logistic function. For example, <span class="math inline">\(\tau(s) = 1/(1+e^{-cs})\)</span> has the property that <span class="math inline">\(\tau(0) = 1/2\)</span> , <span class="math inline">\(\tau(s) \rightarrow 0\)</span> as <span class="math inline">\(s \rightarrow -\infty\)</span> and <span class="math inline">\(\tau(s) \rightarrow 1\)</span> as <span class="math inline">\(s \rightarrow \infty\)</span>. The steepness of the transition from zero to one (the thresholding) can be adjusted via the parameter <span class="math inline">\(c\)</span>, which can be used in conjunction with the scale (standard deviation) of the distribution used as a prior for the latent variable in a Bayesian analysis.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#' plot the logistic function from [-5,5] with three different thresholding constants</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(<span class="at">x =</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">5</span>,<span class="dv">5</span>,.<span class="dv">1</span>), <span class="at">c =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,.<span class="dv">5</span>)) <span class="sc">|&gt;</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="fu">mutate</span>(<span class="at">y =</span> <span class="dv">1</span><span class="sc">/</span>(<span class="dv">1</span><span class="sc">+</span><span class="fu">exp</span>(<span class="sc">-</span>c<span class="sc">*</span>x)))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>df <span class="sc">|&gt;</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> x, <span class="at">y =</span> y, <span class="at">color =</span> <span class="fu">as.factor</span>(c))) <span class="sc">+</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">linewidth =</span> <span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"s"</span>) <span class="sc">+</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">"tau(s)"</span>) <span class="sc">+</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_discrete</span>(<span class="at">name =</span> <span class="st">"c"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-threshold" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-threshold-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="hierarchical_files/figure-html/fig-threshold-1.png" class="img-fluid figure-img" width="480">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-threshold-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: The logistic function, <span class="math inline">\(\tau(s) = 1/(1+e^{-cs})\)</span>, with <span class="math inline">\(c = 1, 2, .5\)</span>.
</figcaption>
</figure>
</div>
</div>
</div>
<p>Use of the threshold function (sometimes called a sigma function because it looks like an S) with a restrictive prior distribution constrains the domain of the latent variables for computational efficiency. This arrangement allows the truth parameters to remain real values, and the log likelihood function to be differentiable, but it approximates a discrete truth value because applying the transformation forces the values toward zero or one. The modification to the likelihood function is straightforward.</p>
<p><span class="math display">\[
L = -\sum_{i,j} \left[ C_{ij}\log(\tau_i(s)a_j + \bar{a_j}p) + \bar{C_{ij}}\log(1 - \tau_i(s)a_j - \bar{a_j}p) \right]
\]</span></p>
<p>This approach is similar to item response theory or Rasche models. One advantage is that it’s straightforward to include predictor variables in the model, for example to estimate the effect of a rater’s experience (e.g.&nbsp;age, number of ratings) on their accuracy.</p>
<p>An alternative approach is the Expectation-Maximization (EM) algorithm, which is a general method for estimating parameters in models with latent variables. The EM algorithm is a two-step process, where the E-step computes the expected value of the latent variables given the current parameter estimates, and the M-step updates the parameter estimates given the expected values of the latent variables. The EM algorithm is guaranteed to converge to a local maximum of the likelihood function, but it is not guaranteed to find the global maximum. In practice, I have not found the EM algorithm to give good results unless the binomial distributions are widely separated in the mixture (e.g.&nbsp;<span class="math inline">\(a &gt; .5\)</span>).</p>
</section>
<section id="probability-instead-of-truth" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Probability Instead of Truth</h1>
<p>An alternative truth model is useful for hierarchical models, where we assume merely that each subject has a probability of being in Class 1, rather than a cryptic truth value. Here we imagine that each subject’s ratings for proficient raters is itself a binomial mixture with mixing parameter <span class="math inline">\(t\)</span>. This is like embedding the whole t-a-p model within each subject, and the combined likelihood function is a binomial mixture that possibly has unique contributions from each subject (if they all have unique true probabilities <span class="math inline">\(t_i\)</span>). The log-likelihood function becomes</p>
<p><span class="math display">\[
L = -\sum_{i,j} \left[ C_{ij}\log(t_ia_j + \bar{a_j}p) + \bar{C_{ij}}\log(1 - t_ia_j - \bar{a_j}p) \right]
\]</span></p>
<p>Where <span class="math inline">\(t_i \epsilon [0,1]\)</span> is a unit scalar probability that subject <span class="math inline">\(i\)</span> is Class 1. Although the notation change is minor, this version of the model has significant differences from the discrete truth model. In the binary truth t-a-p model, each subject’s ratings will have a binomial distribution of the number of class 1 ratings assigned by raters. That distribution will be one of two types, which are summed with the weights <span class="math inline">\(t\)</span> (for true Class 1 cases) and <span class="math inline">\(\bar{t}\)</span> (for true Class 0 cases). This creates a binomial mixture distribution as we have seen, one binomial for each of the true class types, combined by the frequency of each.</p>
<p>If instead of binary truth for each subject, we switch to a probability <span class="math inline">\(t \epsilon [0,1]\)</span>, each rater’s classification is a combination of the possibilities that the subject is truly Class 1 or Class 0. Consider an example where the <span class="math inline">\(t\)</span> scalar is .5 for each subject, indicating that the subjects are half Class 1, but we don’t know which half. The probability of a rater assigning Class 1 is <span class="math inline">\(t_ia + \bar{a}p\)</span> instead of <span class="math inline">\(T_ia_j + \bar{a_j}p\)</span> in the discrete case. The difference is that the accuracy rating is applied partially instead of fully or not at all. For binary truth, it is the <span class="math inline">\(T_ia\)</span> term that creates the mixture of two binomial distributions, and the difference in means between them is <span class="math inline">\(a\)</span>. With probabilistic truth, there is one binomial distribution for each value of <span class="math inline">\(t_i\)</span>, and the absolute difference in means between subject 1 and subject 2 is <span class="math inline">\(|t_1 - t_2|a\)</span>, for constant <span class="math inline">\(a\)</span> and <span class="math inline">\(p\)</span> parameters. If all the subjects have the same truth probability, there’s not a mixture at all, just a single binomial distribution of Class 1 ratings.</p>
<p>This case is somewhat like using the threshold function <span class="math inline">\(\tau(s)\)</span> with a small <span class="math inline">\(c\)</span> parameter that creates a gradual slope threshold. Following this idea, we could let the <span class="math inline">\(c\)</span> parameter itself be fitted as part of the MCMC estimation process. In my limited attempts with this idea, there has not been enough selective pressure on the parameter to matter.</p>
</section>
<section id="a-em-approach" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> A EM Approach</h1>
<p>The expression <span class="math inline">\(ta + \bar{a}p\)</span> in the likelihood function will be maximized when <span class="math inline">\(t=1\)</span>, whether or not a threshold function is used. The nature of the t-a-p model therefore prefers discrete truth values. This suggests an EM type approach where we:</p>
<ol type="1">
<li><em>E step.</em> Compute the individual <span class="math inline">\(t_i\)</span> truth parameters using the probabilistic approach, then round them to 0 or 1.</li>
<li><em>M step.</em> Compute the new fixed effects using the rounded random effects.</li>
<li>Repeat until convergence.</li>
</ol>
<p>I have not yet tried this.</p>
</section>
<section id="model-notation" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Model Notation</h1>
<p>It’s useful to have compact notation to describe the choices for parametrization, and I’ll use the following convention. The t-a-p model has three average parameters with metaphysical truth. The indexed model in the previous section, where truth is probabilistic, can be denoted as <span class="math inline">\(t_i\)</span>-<span class="math inline">\(a_j\)</span>-<span class="math inline">\(p\)</span>, where <span class="math inline">\(i\)</span> indexes subjects and <span class="math inline">\(j\)</span> indexes raters. Extending that model to include partial pooling for the truth parameters can be written <span class="math inline">\(t + t_i\)</span>-<span class="math inline">\(a_j\)</span>-<span class="math inline">\(p\)</span>, to denote the addition of an average truth parameter <span class="math inline">\(t\)</span>. I’m assuming here that Bayesian estimation is used with hyperparameters for the scale of the <span class="math inline">\(t\)</span> parameter.</p>
<p>There is an epistemological complexity in indexed <span class="math inline">\(t_*\)</span>-<span class="math inline">\(a_*\)</span>-<span class="math inline">\(p_*\)</span> models that has practical implications. The three-parameter <span class="math inline">\(t\)</span>-<span class="math inline">\(a\)</span>-<span class="math inline">\(p\)</span> model assumes that each subject <span class="math inline">\(i\)</span> being observed has a true classification of Class 1 or Class 0 as indicated by the random variable <span class="math inline">\(T_i\)</span>. This is different from a model of the <em>probability</em> that a case is in Class 1. In the analysis so far, we’ve only dealt with expectations over a set of observations, so the distinction wasn’t apparent. But if we create individual parameters <span class="math inline">\(a_j\)</span> for each rater, estimating those depends on true classifications of subjects existing, even if we cannot know what they are. Not all computational methods for estimating the parameters are well-suited to enforce the discrete constraint that <span class="math inline">\(t_i \epsilon \{0,1\}\)</span> for each subject <span class="math inline">\(i\)</span>. One work-around is to average out (marginalize) truth values over the ratings for a subject. That idea is outlined in <span class="citation" data-cites="stanuser">@stanuser</span>, section 1.10 and implemented in several algorithms found in <span class="citation" data-cites="carpenter2008multilevel">@carpenter2008multilevel</span>. Another approach is to use a threshold function to map a continuous latent variable to a discrete truth value.</p>
<p>One consideration for a <span class="math inline">\(t_*\)</span>-<span class="math inline">\(a_*\)</span>-<span class="math inline">\(p_*\)</span> model is that we must decide what model relationship there is between the <span class="math inline">\(a_*\)</span> and <span class="math inline">\(p_*\)</span> parameters. The three main options are (1) leave <span class="math inline">\(p\)</span> a global average and don’t estimate indexed parameters for it, (2) assign <span class="math inline">\(p_j\)</span> for each rater, or (3) assign <span class="math inline">\(p_i\)</span> for each subject. The second option is a Cohen kappa approach. Generally this option will have identifiability problems for unbalanced data. To see that, consider <span class="math inline">\(c_{ij} = T_i a_j + \bar{a_j}p_j\)</span> when <span class="math inline">\(T_i = 0\)</span>. If this is the large majority of cases, then the same rating will be obtained from either low accuracy or high guess rates, and the model will not be able to distinguish between them (the kappa paradox situation). This is not the case for the third option, where the <span class="math inline">\(p_i\)</span> parameters are assigned to subjects, not raters. In simulations across a range of conditions, the third option performed best, but more work needs to be done on that.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>