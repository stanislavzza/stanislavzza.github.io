<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="David Eubanks">

<title>Chapter 9: Multinomial Rater Models – The Kappa Zoo</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-fcd204c8655bd031ced4918abb783b1b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-XP6WMESY52"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-XP6WMESY52', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">
      The Kappa Zoo
      </li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">The Kappa Zoo</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#unbiased-raters-the-fleiss-kappa" id="toc-unbiased-raters-the-fleiss-kappa" class="nav-link" data-scroll-target="#unbiased-raters-the-fleiss-kappa"><span class="header-section-number">2</span> Unbiased Raters: the Fleiss Kappa</a></li>
  <li><a href="#likelihood" id="toc-likelihood" class="nav-link" data-scroll-target="#likelihood"><span class="header-section-number">3</span> Likelihood</a></li>
  <li><a href="#units-of-entropy" id="toc-units-of-entropy" class="nav-link" data-scroll-target="#units-of-entropy"><span class="header-section-number">4</span> Units of Entropy</a></li>
  <li><a href="#e-m-algorithm" id="toc-e-m-algorithm" class="nav-link" data-scroll-target="#e-m-algorithm"><span class="header-section-number">5</span> E-M Algorithm</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Chapter 9: Multinomial Rater Models</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>David Eubanks </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>So far I’ve considered binary ratings, with the exception of the ML algorithms like MACE, which are designed for <span class="math inline">\(K\)</span> categories. I downgraded those to binary during that discussion for simplicity. But let’s revisit this question, starting with the Fleiss kappa. You’ll recall that with binary ratings, for unbiased raters (<span class="math inline">\(t=p\)</span>), we have <span class="math inline">\(\kappa = a^2\)</span>. The Fleiss kappa is defined for multinomial ratings, so might it be the case that the same relation holds in that case?</p>
<p>To get there, we have to reimagine the t-a-p model in the case with <span class="math inline">\(K\)</span> categories and <span class="math inline">\(k&gt;2\)</span>. Instead of a binary latent truth <span class="math inline">\(T_i\)</span>, we can allow each subject take on values <span class="math inline">\(1 \dots K\)</span> to indicate the true class. The corresponding probability <span class="math inline">\(t\)</span> now becomes a probability distribution over the <span class="math inline">\(k\)</span> values, so I’ll switch to boldface to indicate a vector. Accuracy need not be vectorized in the simplest case, but the random assignment rate <span class="math inline">\(p\)</span> also needs to become a distribution.</p>
<p>With vectorized <span class="math inline">\(\boldsymbol{t}\)</span> and <span class="math inline">\(\boldsymbol{p}\)</span> the convention <span class="math inline">\(\bar{p} = 1-p\)</span> no longer makes sense. Instead, I’ll use matrix multiplication, assuming column vectors. So the probability of two random classifications matching is <span class="math inline">\(\boldsymbol{p}^t\boldsymbol{p} = \sum_k{p_k^2}\)</span> where <span class="math inline">\(p_k\)</span> is the <span class="math inline">\(k\)</span>th element of the vector <span class="math inline">\(\boldsymbol{p}\)</span>, and the <span class="math inline">\(t\)</span> superscript means transpose from column to row vector to make a dot product.</p>
<p>Recall that kappas are based on match rates using a formula that’s agnostic to <span class="math inline">\(K\)</span>. For two ratings to match, two raters <span class="math inline">\(j_1,j_2\)</span> of the same subject <span class="math inline">\(i\)</span> must agree in their assignment of either Class 1 or Class 0 classifications. In other words, the binary random variables must agree: <span class="math inline">\(C_{ij_1} = C_{ij_2}\)</span>, which now may be an integer 1 to <span class="math inline">\(K\)</span>. A generic formula that includes the most common kappas is</p>
<p><span class="math display">\[
\kappa = \frac{m_o - m_c}{1 - m_c},
\]</span> where <span class="math inline">\(m_o\)</span> is the observed proportion of agreements and <span class="math inline">\(m_c\)</span> is the expected proportion of agreements under chance. The assumption about <span class="math inline">\(m_c\)</span> is a defining feature of the various kappa statistics.</p>
<p>Consider two raters classifying an observation into <span class="math inline">\(K\)</span> categories. In the t-a-p model we can express the expected value of observed matches <span class="math inline">\(m_o\)</span> as the sum of three kinds of agreement: (1) <span class="math inline">\(m_a\)</span> is when both raters are accurate (and hence agree), (2) <span class="math inline">\(m_i\)</span> when both raters are inaccurate (guessing) and agree, and (3) <span class="math inline">\(m_x\)</span> is the mixed case when one rater is accurate and the other is inaccurate but they agree. The second two of these have expressions that include the guessing rate <span class="math inline">\(m_c\)</span>. Following that thinking we have the following expectations for rates:</p>
<p><span id="eq-match-rates"><span class="math display">\[
\begin{aligned}
m_a &amp;= a^2 &amp; \text{(both accurate)}\\
m_r &amp;= \boldsymbol{p}^t\boldsymbol{p}  &amp; \text{(random ratings)}\\
m_i &amp;= \bar{a}^2m_r = a^2m_r - 2am_r + m_r &amp;\text{(both inaccurate)}\\
m_x &amp;= 2a\bar{a}\boldsymbol{t}^t\boldsymbol{p} &amp;\text{(mixed accurate and inaccurate)}\\
m_o &amp;= m_a + m_i + m_x &amp;\text{(observed match rate)}\\
    &amp;= a^2+a^2m_r + m_r - 2am_r + 2a\bar{a}\boldsymbol{t}^t\boldsymbol{p}\\
\end{aligned}
\tag{1}\]</span></span></p>
<p>For <span class="math inline">\(m_a\)</span>, both ratings must be accurate, in which case they automatically agree. For <span class="math inline">\(m_i\)</span>, both must be inaccurate (probability <span class="math inline">\(\bar{a}^2\)</span>) and then match randomly (probability <span class="math inline">\(m_r\)</span>). For <span class="math inline">\(m_x\)</span>, one rater must be accurate and the other inaccurate, in which case they agree if the accurate rater chooses the category that the inaccurate rater guesses.</p>
</section>
<section id="unbiased-raters-the-fleiss-kappa" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Unbiased Raters: the Fleiss Kappa</h1>
<p>Recall that in terms of the t-a-p model, the Fleiss kappa assumes that the by-chance match rate in the kappa formula comes from the observed rate of each category. Random matches are assumed to have the same distribution as the overall ratings distribution. In the vectorized <strong>t</strong>-a-<strong>p</strong> model, this amounts to finding <span class="math inline">\(\boldsymbol{c} = \boldsymbol{t}a + \bar{a}\boldsymbol{p}\)</span>, and the by-chance match rate in the kappa formula is <span class="math inline">\(m_c = \boldsymbol{c}^t\boldsymbol{c}\)</span>. Under the unbiased rater assumption, where <span class="math inline">\(\boldsymbol{p} = \boldsymbol{t}\)</span> after a bit of algebra we get <span class="math inline">\(m_c = \boldsymbol{p}^t \boldsymbol{p} = m_r\)</span>.</p>
<p>With that result we can tackle the kappa,</p>
<p><span class="math display">\[
\begin{aligned}\kappa_f &amp;= \frac{m_o - m_c}{1 - m_c} \\
&amp;= \frac{a^2+a^2m_r + m_r - 2am_r + 2a\bar{a}m_r - m_r}{1 - m_r} \\
&amp;= a^2.
\end{aligned}
\]</span></p>
<p>With vectorized truth and randomness, the math looks just like the binary case, and we get the same result: when the <span class="math inline">\(\boldsymbol{p} = \boldsymbol{t}\)</span> condition is met, kappa is the square of accuracy. This is a nice result, because it gives us a direct way to check multinomial solvers that use unbiased simulated ratings with multiple categories.</p>
</section>
<section id="likelihood" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Likelihood</h1>
<p>The likelihood function for the multinomial case is similar to the binary case. The difference is in the sum, which is over each class. We have</p>
<p><span id="eq-likelihood"><span class="math display">\[
\begin{aligned}
\text{Pr(ratings; parameters)} &amp;= \prod_{i=1}^{N_s} \sum_{k_T = 1}^Kt_{k_T}^{(i)}\prod_{j}\pi_{k_Tk_{ij}}^{(j)} \, ,
\end{aligned}
\tag{2}\]</span></span></p>
<p>where the leftmost product is over subjects, and the sum is over the <span class="math inline">\(K\)</span> classes, where we pull subject <span class="math inline">\(i\)</span>’s truth estimates <span class="math inline">\(\boldsymbol{t}\)</span> and extract the elements one by one. The innermost product is over all the ratings, indexed by the rater <span class="math inline">\(j\)</span>, the assigned rating <span class="math inline">\(k_{ij}\)</span> and each possible true Class <span class="math inline">\(k_T\)</span>. The rater likelihood is</p>
<p><span class="math display">\[
\begin{aligned}
\pi_{k_Tk_{ij}}^{(j)} &amp;= \text{Pr(assigned rating = }k_{ij}\text{; true class = }k_T) \\
&amp;= \bar{a}_jp_{k_T}^{(j)} + a_jI(k_j = k_T).
\end{aligned}
\]</span> Here, <span class="math inline">\(I\)</span> is an indicator function that is one when the assigned rating equals the assumed true rating, and zero otherwise.</p>
<p>In practice, we compute the log likelihood, and I’ll use the same approach as the binary case, adapted to <span class="math inline">\(K\)</span> classes. Instead of log likelihood as bits per rating, using base 1/2, it is “krits” per rating, short for k-ary digit. Using log base <span class="math inline">\(1/K\)</span> and averaging over ratings again gives us a range of entropy in [0,1]. When <span class="math inline">\(a=1\)</span> the ratings are deterministic (no randomness) and the entropy is zero. For uniform <span class="math inline">\(\boldsymbol{p}\)</span> and <span class="math inline">\(\boldsymbol{t}\)</span> with <span class="math inline">\(a=0\)</span>, entropy is 1 krit/rating. See the code sample below for an example.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tapModel)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># zero accuracy case with the correct model</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">generate_sample_ratings_cat</span>(<span class="at">N_s =</span> <span class="dv">200</span>, <span class="at">N_r =</span> <span class="dv">10</span>, <span class="at">K =</span> <span class="dv">4</span>, </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                            <span class="at">params =</span> <span class="fu">list</span>(<span class="at">t =</span> <span class="fu">rep</span>(.<span class="dv">25</span>,<span class="dv">4</span>),</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">a =</span> <span class="dv">0</span>,</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">p =</span> <span class="fu">rep</span>(.<span class="dv">25</span>, <span class="dv">4</span>))) <span class="sc">|&gt;</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">krits_per_rating_cat</span>() <span class="co"># = 1</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co"># a = 1 case, using fit_ratings_cat() to impute good t values</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="fu">generate_sample_ratings_cat</span>(<span class="at">N_s =</span> <span class="dv">200</span>, <span class="at">N_r =</span> <span class="dv">10</span>, <span class="at">K =</span> <span class="dv">4</span>, </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>                            <span class="at">params =</span> <span class="fu">list</span>(<span class="at">t =</span> <span class="fu">rep</span>(.<span class="dv">25</span>,<span class="dv">4</span>),</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">a =</span> <span class="dv">1</span>,</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">p =</span> <span class="fu">rep</span>(.<span class="dv">25</span>, <span class="dv">4</span>)),</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                            <span class="at">details =</span> <span class="cn">TRUE</span>) <span class="sc">|&gt;</span> </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fit_ratings_cat</span>() <span class="sc">|&gt;</span> </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">krits_per_rating_cat</span>() <span class="co"># = 0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can express the log likelihood <span class="math inline">\(\ell\)</span> compactly in vector form with</p>
<p><span class="math display">\[
\begin{aligned}
\ell(\text{ratings; parameters}) &amp;= -\sum_{i=1}^{N_s} \| \log \boldsymbol{t}_i +
\sum_j \boldsymbol{\pi}_j \|_1
\end{aligned}
\]</span> where each subject <span class="math inline">\(i\)</span> has a vector <span class="math inline">\(\boldsymbol{t}_i\)</span> of estimated class probabilites, and each rater <span class="math inline">\(j\)</span> has a vector <span class="math inline">\(\boldsymbol{\pi}_j\)</span> of conditional class probabilities based on the rating of that subject. All the logs are non-positive, so the norm and minus sign are a notation hack that just means “add up the vector components.”</p>
</section>
<section id="units-of-entropy" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Units of Entropy</h1>
<p>For binary ratings I adopted the convention of finding the average log likelihood per rating and using log base 1/2, so the answer is in bits. Here we only need to switch to log base 1/K to have the same benefits.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>In the K-class case I will use the convention that <span class="math inline">\(\log x\)</span> means <span class="math inline">\(\log_{\frac{1}{K} } x\)</span>, without specifying the base each time. I nominate “krits” (for “k-ary digits”) as the unit of entropy, following Tukey’s bits, trits, and dits. As with the binary case when we maximize likelihood, we <em>minimize</em> the number of informational krits per rating.</p>
</div>
</div>
<p>As with the binary case, we can estimate log likelihood from parameters by assuming that the probabilities <span class="math inline">\(t_i\)</span> closely approximate indicator vectors. These “one-hot” vectors like <span class="math inline">\((1, 0, 0)\)</span> or <span class="math inline">\((0,1,0)\)</span> exactly identify a single class for each subject. In that case, the sum in <a href="#eq-likelihood" class="quarto-xref">Equation&nbsp;2</a> collapses to a single value of <span class="math inline">\(t_{k_T}\)</span> for each subject. In the <span class="math inline">\(K=3\)</span> case it looks like</p>
<p><span id="eq-likelihood2"><span class="math display">\[
Pr(\text{data ; parameters, }K = 3 ) = \prod_{T_i = 1}\pi_{1k_{ij}}^{(j)} \prod_{T_i = 2}  \pi_{2k_{ij}}^{(j)} \prod_{T_i = 3}  \pi_{3k_{ij}}^{(j)} \,,
\tag{3}\]</span></span></p>
<p>where the products are over all ratings <span class="math inline">\(k_{ij}\)</span> sorted by the true class as indicated by the <span class="math inline">\(\boldsymbol{t}_i\)</span> vectors. I’ll approximate further by assuming an average model with parameters <span class="math inline">\(boldsymbol{t}\)</span> representing the proportions of true classes over all subjects, a constant rater accuracy <span class="math inline">\(a\)</span>, a constant random assignment rate <span class="math inline">\(boldsymbol{p}\)</span>.</p>
<p>The key insight is that <span class="math inline">\(\pi_{1k_T}\)</span> is expected to occur at a rate of <span class="math inline">\(\pi_{1k_T}\)</span>, since that’s it’s definition. There will be <span class="math inline">\(Nt_1\pi_{1k}\)</span> contributions of <span class="math inline">\(\log \pi_{1k}\)</span> in the log likelihood sum, on average.</p>
<p>Taking logs, we have an expectation averaged over <span class="math inline">\(N\)</span> ratings of</p>
<p><span class="math display">\[
\begin{aligned}
E[\ell(\text{data ; parameters})]/N &amp;= E \left[ \sum_{k_T = 1}^K \log \pi_{k_Tk} \right]/N \\
&amp;= \sum_{k_T = 1}^K t_{k_T}\sum_{k=1}^K \pi_{k_Tk} \log \pi_{k_Tk} \, .\\
\end{aligned}
\]</span></p>
<p>The inner sum has the form of Shannon entropy, which represents the average krits per rating for each assigned class <span class="math inline">\(k = 1 \dots K\)</span>. The total entropy per rating is the weighted average of these using true class rates as weights. Note that the expected entropy only depends on a model specification, not any actual ratings, and it would only be relevant to ratings generated from that model.</p>
<p>If we set all the components of <span class="math inline">\(boldsymbol{t}\)</span> to <span class="math inline">\(1/K\)</span>, we obtain a kind of standardized rater entropy that’s independent of sampling subjects.</p>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>K <span class="ot">&lt;-</span> <span class="dv">4</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>t_p <span class="ot">&lt;-</span> <span class="fu">tribble</span>(<span class="sc">~</span>run, <span class="sc">~</span>t, <span class="sc">~</span>p,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>              <span class="dv">1</span>, <span class="fu">c</span>(.<span class="dv">1</span>,.<span class="dv">1</span>,.<span class="dv">4</span>,.<span class="dv">4</span>), <span class="fu">c</span>(.<span class="dv">1</span>,.<span class="dv">1</span>,.<span class="dv">4</span>,.<span class="dv">4</span>), <span class="co"># skewed, unbiased</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>              <span class="dv">2</span>, <span class="fu">c</span>(.<span class="dv">1</span>,.<span class="dv">1</span>,.<span class="dv">4</span>,.<span class="dv">4</span>), <span class="fu">c</span>(.<span class="dv">4</span>,.<span class="dv">4</span>,.<span class="dv">1</span>,.<span class="dv">1</span>), <span class="co"># skewed, biased</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>              <span class="dv">3</span>, <span class="fu">rep</span>(.<span class="dv">25</span>, <span class="dv">4</span>), <span class="fu">rep</span>(.<span class="dv">25</span>, <span class="dv">4</span>))       <span class="co"># uniform, unbiased</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>output <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">a =</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,.<span class="dv">05</span>), <span class="at">LL =</span> <span class="cn">NA</span>, <span class="at">E_LL =</span> <span class="cn">NA</span>) <span class="sc">|&gt;</span> </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>          <span class="fu">cross_join</span>(t_p)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(output)){</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  params <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">t =</span> <span class="fu">unlist</span>(output<span class="sc">$</span>t[i]), <span class="at">a =</span> output<span class="sc">$</span>a[i], <span class="at">p =</span> <span class="fu">unlist</span>(output<span class="sc">$</span>p[i]))</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># simulate data</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  cat_ratings <span class="ot">&lt;-</span> <span class="fu">generate_sample_ratings_cat</span>(<span class="at">N_s =</span> <span class="dv">100</span>, <span class="at">K =</span> K, <span class="at">params =</span> params, <span class="at">details =</span> <span class="cn">TRUE</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># replace subject t with indicator of true value</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  cat_ratings<span class="sc">$</span>subjects <span class="ot">&lt;-</span> cat_ratings<span class="sc">$</span>subjects <span class="sc">|&gt;</span> </span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mutate</span>(<span class="at">t =</span> <span class="fu">lc_indicator</span>(T_i, K)) <span class="sc">|&gt;</span> </span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="fu">select</span>(<span class="sc">-</span>T_i)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>  <span class="co"># use the average t-a-p params used to generate the data as heirarchical </span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>  <span class="co"># values for raters, and estimate from that the t_i values for each </span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>  <span class="co"># subject.</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">#cat_ratings &lt;- cat_ratings |&gt; </span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">#  e_m_step_cat(group = FALSE)</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>  <span class="co"># store results</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>  output<span class="sc">$</span>LL[i] <span class="ot">&lt;-</span> <span class="fu">krits_per_rating_cat</span>(cat_ratings)</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>  output<span class="sc">$</span>E_LL[i] <span class="ot">&lt;-</span> <span class="fu">expected_krits_per_rating_cat</span>(params)</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>output <span class="sc">%&gt;%</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gather</span>(type, value, LL, E_LL) <span class="sc">%&gt;%</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>    <span class="at">model =</span> <span class="fu">str_c</span>(run),</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="at">type =</span> <span class="fu">recode</span>(type, </span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>                  <span class="at">LL =</span> <span class="st">"Empirical"</span>,</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>                  <span class="at">E_LL =</span> <span class="st">"Expected"</span>),   <span class="co"># nice legend labels</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    <span class="at">type =</span> <span class="fu">factor</span>(type, <span class="at">levels =</span> <span class="fu">c</span>(<span class="st">"Empirical"</span>, <span class="st">"Expected"</span>))</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> a, <span class="at">y =</span> value, <span class="at">color =</span> model, <span class="at">group =</span> <span class="fu">interaction</span>(model, type),</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>             <span class="at">linetype =</span> type)) <span class="sc">+</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">"Krits per rating"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-rater-entropy" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-rater-entropy-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="multinomial_kappa_files/figure-html/fig-rater-entropy-1.png" class="img-fluid figure-img" width="480">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-rater-entropy-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Log likelihood in krits per rating for three sets of parameters, with 100 samples and five raters. The dotted lines are the expected values and the solid lines are the empirical ones, which have sampling noise. Parameter sets are 1 = skewed, unbiased, 2 = skewed, biased, 3 = uniform, unbiased.
</figcaption>
</figure>
</div>
</div>
</div>
<p>In <a href="#fig-rater-entropy" class="quarto-xref">Figure&nbsp;1</a> the rater models each have fixed parameters with <span class="math inline">\(a\)</span> varying to show the effect of changing accuracy. The other parameters are</p>
<ul>
<li>Model 1: <span class="math inline">\(\boldsymbol{t} = (.1,.1,.4,.4), \boldsymbol{p} = (.1,.1,.4,.4)\)</span></li>
<li>Model 2: <span class="math inline">\(\boldsymbol{t} = (.1,.1,.4,.4), \boldsymbol{p} = (.4,.4,.1,.1)\)</span></li>
<li>Model 3: <span class="math inline">\(\boldsymbol{t} = (.25,.25,.25,.25), \boldsymbol{p} = (.25,.25,.25,.25)\)</span>,</li>
</ul>
<p>so models 1 and 3 have the <span class="math inline">\(\boldsymbol{t} = \boldsymbol{p}\)</span> property, which we called unbiasedness. The variation in the solid lines comes from sampling, so that the empirical class rates don’t exactly match the model specifications. We can see in model 2 that maximum likelihood in krits per rating doesn’t always occure when <span class="math inline">\(a = 0\)</span>.</p>
</section>
<section id="e-m-algorithm" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> E-M Algorithm</h1>
<p>As with the binary case, we can estimate model parameters from ratings data using a two-step iterative process called an Expectation-Maximization algorithm. The E-step of the multinomial case looks like the binary case, just with more classes. The likelihood contribution for a single subject <span class="math inline">\(i\)</span> is</p>
<p><span class="math display">\[
\begin{aligned}
\text{Pr(ratings; parameters, subject }i) &amp;= \sum_{k_T = 1}^Kt_{k_T}^{(i)}\prod_{j}\pi_{k_Tk_{ij}}^{(j)} \, ,
\end{aligned}
\]</span> from which we extract new estimates of class probabilities via</p>
$$
<span class="math display">\[\begin{aligned}
t_{k_T}^* &amp;\approx  Pr(\text{True class } = k_T  ;\text{ parameters, ratings)} \\
&amp;=\frac{t_{k_T}\prod_{j}\pi_{{k_T}k_{ij}}^{(j)}}{ \sum_{k_T = 1}^Kt_{k_T}\prod_{j}\pi_{{k_T}k_{ij}}^{(j)} } ,
\end{aligned}\]</span>
<p>$$ where it is understood that we’re referring to subject <span class="math inline">\(i\)</span>, so I have removed those annotations. The <span class="math inline">\(t_{k_t}^*\)</span> result on the left is the updated class probability that subject <span class="math inline">\(i\)</span> is class <span class="math inline">\(k_T \, \epsilon \{1 \dots K\}\)</span>.</p>
<p>To derive the M-step of the algorithm we need to expand the 2x2 confusion matrix to KxK. The matrix consists of probabilities, where the <span class="math inline">\(i,j\)</span> entry contains <span class="math inline">\(Pr(\text{Rating = }j | \text{True class }= i)\)</span>. Confusion matricies are sometimes row-normalized, but this one is not; it’s the intersection of true class values (rows) with rated classes (columns). The empirical matrix comprises the proportions of ratings that fall within each of these groups, which enables us to compare a model with a data set. I’ll illustrate with the <span class="math inline">\(K=3\)</span> case, where the model’s expected value of these proportions is</p>
<p><span class="math display">\[
E[C] =
\begin{bmatrix}
t_1(a + \bar{a}p_1) &amp; t_1\bar{a}p_2 &amp; t_1\bar{a}p_3 \\
t_2\bar{a}p_1 &amp; t_2(a + \bar{a}p_2) &amp; t_2\bar{a}p_3 \\
t_3\bar{a}p_1 &amp; t_3\bar{a}p_2 &amp; t_3(a + \bar{a}p_3)
\end{bmatrix} .
\]</span> Here, <span class="math inline">\((t_1, t_2, t_3)\)</span> are the class probabilities, which we can more compactly express as a vector <span class="math inline">\(\boldsymbol{t}\)</span>, and similarly with the <span class="math inline">\(p\)</span> parameters. The empirical <span class="math inline">\(\hat{C}\)</span> we get from the ratings combined with the class probabilities <span class="math inline">\(\boldsymbol{\hat{t}}\)</span> obtained in the E-step.</p>
<p>To solve for the parameters, we can start with the sum of the diagonals (the trace of the matrix), to get</p>
<p><span class="math display">\[
\begin{aligned}
\text{trace}(E[C]) &amp;= t_1(a + \bar{a}p_1) + t_2(a + \bar{a}p_2) + t_3(a + \bar{a}p_3) \\
&amp;= a(t_1 + t_2 + t_3) + \bar{a}(t_1p_1+ t_2p_2+t_3p_3) \\
&amp;= a + \bar{a}\boldsymbol{t}^t\boldsymbol{p} \\
&amp; \approx \text{trace}(\hat{C}) ,
\end{aligned}
\]</span> which gives us one equation linking the model to the data. We can sum the off-diagonal columns to get similar equations relating to the components of <span class="math inline">\(\boldsymbol{p}\)</span>. For the first column, we have</p>
<p><span class="math display">\[
\begin{aligned}
E[c_{21} + c_{31}] &amp;= t_2\bar{a}p_1 + t_3\bar{a}p_1 \\
&amp;= \bar{t}_1\bar{a}p_1 \\
&amp; \approx \hat{c}_{21} + \hat{c}_{31} \\
&amp;:= \hat{C}_{o1},
\end{aligned}
\]</span> where in the definition in the last step the o means “off-diagonal”, and the 1 means sum over column 1. Recall that we already have estimates for <span class="math inline">\(\boldsymbol{t}\)</span> at this point, and wish to solve for <span class="math inline">\(a\)</span> and <span class="math inline">\(\boldsymbol{p}\)</span>. If we sum the three off-diagonals we obtain <span class="math inline">\(\bar{a}-\bar{a}\boldsymbol{t}^t\boldsymbol{p} = 1 -\text{trace}(E[C])\)</span>, since all the elements of <span class="math inline">\(C\)</span> sum to 1.</p>
<p>Solving each of the off-diagonal sums for <span class="math inline">\(p_i\)</span> gives us a way to combine with the trace equation and solve for <span class="math inline">\(a\)</span>. Start with <span class="math inline">\(p_1 \approx \hat{C}_{o1}/(\bar{t}_1\bar{a})\)</span> and substitute to obtain</p>
<p><span class="math display">\[
\begin{aligned}
\text{trace}(\hat{C}) &amp; \approx a +  \bar{a}(t_1p_1+ t_2p_2+t_3p_3) \\
&amp;= a + \bar{a} \left(\frac{t_1\hat{C}_{o1}}{\bar{t}_1\bar{a}}  \right) +
\bar{a} \left(\frac{t_2\hat{C}_{o2}}{\bar{t}_2\bar{a}}  \right) +
\bar{a} \left(\frac{t_3\hat{C}_{o3}}{\bar{t}_3\bar{a}}  \right) \\
&amp;= a + \frac{t_1}{\bar{t}_1}\hat{C}_{o1} + \frac{t_2}{\bar{t}_2}\hat{C}_{o2} + \frac{t_3}{\bar{t}_3}\hat{C}_{o3}  \\
\end{aligned}
\]</span></p>
<p>This gives us a simple calculation for the accuracy coefficient, from which we can derive an approximation for <span class="math inline">\(\boldsymbol{p}\)</span> as well:</p>
<p><span class="math display">\[
\begin{aligned}
a &amp; \approx  \text{trace}(\hat{C}) - \left(\frac{t_1}{\bar{t}_1}\hat{C}_{o1} + \frac{t_2}{\bar{t}_2}\hat{C}_{o2} + \frac{t_3}{\bar{t}_3}\hat{C}_{o3} \right) \\
p_i &amp; \approx \frac{\hat{C}_{oi}}{\bar{t}_i\bar{a}}.
\end{aligned}
\]</span></p>
<p>The formula for <span class="math inline">\(a\)</span> gives us some insight into the t-a-p model. When <span class="math inline">\(a=1\)</span> the ratings will match true values, so the matrix will be diagonal with values <span class="math inline">\(\boldsymbol{t}\)</span>. When <span class="math inline">\(a = 0\)</span> we get the outer product <span class="math inline">\(C = \boldsymbol{t}\boldsymbol{p}^t\)</span>.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/kappazoo\.com\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>